#!@TCLSHDIR@/tclsh
#
# MODULECMD.TCL, a pure TCL implementation of the module command
# Copyright (C) 2002-2004 Mark Lakata
# Copyright (C) 2004-2017 Kent Mein
# Copyright (C) 2016-2021 Xavier Delaruelle
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

##########################################################################

##############################################################################
# Configuration and state handling -------------------------------------------
##############################################################################

# Runtime state properties (default value, proc to call to initialize state
# value?)
array set g_state_defs [list\
   autoinit {0}\
   clock_seconds {<undef> initStateClockSeconds}\
   domainname {<undef> {runCommand domainname}}\
   error_count {0}\
   extra_siteconfig_loaded {0}\
   false_rendered {0}\
   force {0}\
   hiding_threshold {0}\
   inhibit_errreport {0}\
   inhibit_interp {0}\
   init_error_report {0}\
   is_stderr_tty {<undef> initStateIsStderrTty}\
   is_win {<undef> initStateIsWin}\
   kernelversion {<undef> {runCommand uname -v}}\
   lm_info_cached {0}\
   machine [list $::tcl_platform(machine)]\
   nodename {<undef> {runCommand uname -n}}\
   os [list $::tcl_platform(os)]\
   osversion [list $::tcl_platform(osVersion)]\
   paginate {<undef> initStatePaginate}\
   path_separator {<undef> initStatePathSeparator}\
   report_format {regular}\
   reportfd {stderr initStateReportfd}\
   return_false {0}\
   siteconfig_loaded {0}\
   sub1_separator {&}\
   sub2_separator {|}\
   tcl_ext_lib_loaded {0}\
   tcl_version [list [info patchlevel]]\
   tcl_version_lt85 {<undef> initStateTclVersionLt85}\
   term_columns {<undef> initStateTermColumns}\
   usergroups {<undef> initStateUsergroups}\
   username {<undef> initStateUsername}\
]

# Configuration option properties (superseding environment variable, default
# value, is configuration lockable to default value, valid value list?,
# internal value representation?, proc to call to initialize option value,
# valid value list kind
array set g_config_defs [list\
   contact {MODULECONTACT root@localhost 0}\
   auto_handling {MODULES_AUTO_HANDLING @autohandling@ 0 {0 1}}\
   avail_indepth {MODULES_AVAIL_INDEPTH @availindepth@ 0 {0 1}}\
   avail_output {MODULES_AVAIL_OUTPUT {@availoutput@} 0 {modulepath alias\
      dirwsym sym tag key} {} {} eltlist}\
   avail_terse_output {MODULES_AVAIL_TERSE_OUTPUT {@availterseoutput@} 0\
      {modulepath alias dirwsym sym tag key} {} {} eltlist}\
   collection_pin_version {MODULES_COLLECTION_PIN_VERSION 0 0 {0 1}}\
   collection_target {MODULES_COLLECTION_TARGET <undef> 0}\
   color {MODULES_COLOR @color@ 0 {never auto always} {0 1 2} initConfColor}\
   colors {MODULES_COLORS {} 0 {} {} initConfColors}\
   csh_limit {{} 4000 0}\
   extra_siteconfig {MODULES_SITECONFIG <undef> 1 {}}\
   editor {MODULES_EDITOR {@editor@} 0 {} {} initConfEditor}\
   home {MODULESHOME @moduleshome@ 0}\
   icase {MODULES_ICASE @icase@ 0 {never search always}}\
   ignored_dirs {{} {CVS RCS SCCS .svn .git .SYNC .sos} 0}\
   implicit_requirement {MODULES_IMPLICIT_REQUIREMENT @implicitrequirement@ 0\
      {0 1}}\
   list_output {MODULES_LIST_OUTPUT {@listoutput@} 0 {header idx variant sym\
      tag key} {} {} eltlist}\
   list_terse_output {MODULES_LIST_TERSE_OUTPUT {@listterseoutput@} 0 {header\
      idx variant sym tag key} {} {} eltlist}\
   locked_configs {{} {@lockedconfigs@} 0}\
   mcookie_version_check {MODULES_MCOOKIE_VERSION_CHECK\
      @mcookieversioncheck@ 0 {0 1}}\
   ml {MODULES_ML @ml@ 0 {0 1}}\
   nearly_forbidden_days {MODULES_NEARLY_FORBIDDEN_DAYS @nearlyforbiddendays@\
      0 {0 365} {} {} intbe}\
   pager {MODULES_PAGER {@pagercmd@} 0}\
   rcfile {MODULERCFILE <undef> 0}\
   run_quarantine {MODULES_RUN_QUARANTINE <undef> 0}\
   shells_with_ksh_fpath {MODULES_SHELLS_WITH_KSH_FPATH {} 0 {sh bash csh\
      tcsh fish} {} {} eltlist}\
   silent_shell_debug {MODULES_SILENT_SHELL_DEBUG <undef> 0 {0 1}}\
   siteconfig {{} @etcdir@/siteconfig.tcl 0}\
   tag_abbrev {MODULES_TAG_ABBREV {@tagabbrev@} 0 {} {} initConfTagAbbrev}\
   tag_color_name {MODULES_TAG_COLOR_NAME {@tagcolorname@} 0 {} {}\
      initConfTagColorName}\
   tcl_ext_lib {{} {} 0 {} {} initConfTclExtLib}\
   term_background {MODULES_TERM_BACKGROUND @termbg@ 0 {dark light}}\
   term_width {MODULES_TERM_WIDTH 0 0 {0 1000} {} {} intbe}\
   unload_match_order {MODULES_UNLOAD_MATCH_ORDER @unloadmatchorder@ 0\
      {returnlast returnfirst}}\
   implicit_default {MODULES_IMPLICIT_DEFAULT @implicitdefault@ 1 {0 1}}\
   extended_default {MODULES_EXTENDED_DEFAULT @extendeddefault@ 0 {0 1}}\
   advanced_version_spec {MODULES_ADVANCED_VERSION_SPEC @advversspec@ 0 {0\
      1}}\
   search_match {MODULES_SEARCH_MATCH @searchmatch@ 0 {starts_with contains}}\
   set_shell_startup {MODULES_SET_SHELL_STARTUP @setshellstartup@ 0 {0 1}}\
   variant_shortcut {MODULES_VARIANT_SHORTCUT {@variantshortcut@} 0 {} {}\
      initConfVariantShortcut}\
   verbosity {MODULES_VERBOSITY @verbosity@ 0 {silent concise normal verbose\
      verbose2 trace debug debug2}}\
   wa_277 {MODULES_WA_277 @wa277@ 0 {0 1}}\
]

# Get state value
proc getState {state {valifundef {}} {catchinitproc 0}} {
   if {![info exists ::g_states($state)]} {
      # fetch state properties (including its default value) if defined
      if {[info exists ::g_state_defs($state)]} {
         lassign $::g_state_defs($state) value initproclist
      } else {
         set value <undef>
         set initproclist {}
      }

      # call specific proc to initialize state if any
      if {$initproclist ne {}} {
         # catch init procedure error and report it as warning, so default
         # value will get set for state
         if {$catchinitproc} {
            if {[catch {set value [{*}$initproclist]} errMsg]} {
               reportWarning $errMsg
            }
         } else {
            set value [{*}$initproclist]
         }
      # overridden value coming the command-line
      } elseif {[info exists ::asked_$state]} {
         set value [set ::asked_$state]
      }

      # return passed value if undefined and no value record
      if {$value eq {<undef>}} {
         set value $valifundef
      } else {
         setState $state $value
      }
      return $value
   } else {
      return $::g_states($state)
   }
}

# Clear state
proc unsetState {state} {
   unset ::g_states($state)
   reportDebug "$state unset"
}

# Set state value
proc setState {state value} {
   set ::g_states($state) $value
   reportDebug "$state set to '$value'"
}

# Append each passed value to the existing state value list
proc lappendState {state args} {
   if {$state eq {-nodup}} {
      set state [lindex $args 0]
      # retrieve current val through getState to initialize it if still undef
      set value [getState $state]
      appendNoDupToList value {*}[lrange $args 1 end]
      setState $state $value
   } else {
      lappend ::g_states($state) {*}$args
      reportDebug "$state appended with '$args'"
   }
}

# Remove last element from state value list
proc lpopState {state} {
   setState $state [lrange [getState $state] 0 end-1]
}

# Return first element from state value list
proc topState {state} {
   return [lindex [getState $state] 0]
}

# Return last element from state value list
proc currentState {state} {
   return [lindex [getState $state] end]
}

# Get number of element from state value list
proc depthState {state} {
   return [llength [getState $state]]
}

# Check if state has been defined
proc isStateDefined {state} {
   return [info exists ::g_states($state)]
}

# Check if state equals passed value
proc isStateEqual {state value} {
   return [expr {[getState $state] eq $value}]
}

proc isConfigLocked {option} {
   return [expr {[lsearch -exact [getConf locked_configs] $option] != -1}]
}

# Get configuration option value
proc getConf {option {valifundef {}}} {
   if {![info exists ::g_configs($option)]} {
      # fetch option properties (including its default value)
      lassign $::g_config_defs($option) envvar value islockable validvallist\
         intvallist initproc validvallistkind

      # ensure option is not locked before superseding its default value
      if {!$islockable || ![isConfigLocked $option]} {
         # call specific proc to initialize config option if any
         if {$initproc ne {}} {
            set value [$initproc $envvar $value $validvallist $intvallist]
         } else {
            # overridden value coming from environment
            if {$envvar ne {} && [info exists ::env($envvar)]} {
               switch -- $validvallistkind {
                  eltlist {
                     # ignore non-valid values
                     if {![isDiffBetweenList [split $::env($envvar) :]\
                        $validvallist]} {
                        set value $::env($envvar)
                     }
                  }
                  intbe {
                     # ignore non-valid values
                     if {[string is integer -strict $::env($envvar)] &&\
                        $::env($envvar) >= [lindex $validvallist 0] &&\
                        $::env($envvar) <= [lindex $validvallist 1]} {
                        set value $::env($envvar)
                     }
                  }
                  {} {
                     # ignore non-valid values
                     if {[switch -- [llength $validvallist] {
                        0 {expr {1 == 1}}
                        1 {string is $validvallist -strict $::env($envvar)}
                        default {expr {$::env($envvar) in $validvallist}}
                     }]} {
                        set value $::env($envvar)
                     }
                  }
               }
            }

            # overridden value coming the command-line (already validated)
            if {[info exists ::asked_$option]} {
               set value [set ::asked_$option]
            }

            # convert value to its internal representation
            if {[llength $intvallist] > 0} {
               set value [lindex $intvallist [lsearch -exact $validvallist\
                  $value]]
            }
         }
      }

      # return passed value if undefined and no value record
      if {$value eq {<undef>}} {
         set value $valifundef
      } else {
         setConf $option $value
      }
      return $value
   } else {
      return $::g_configs($option)
   }
}

# Set configuration option value
proc setConf {option value} {
   set ::g_configs($option) $value
   reportDebug "$option set to '$value'"
}

# Unset configuration option value if it is set
proc unsetConf {option} {
   if {[info exists ::g_configs($option)]} {
      unset ::g_configs($option)
      reportDebug "$option unset"
   }
}

# Append each passed value to the existing config option value list
proc lappendConf {option args} {
   # retrieve current value through getConf to initialize it if still undef
   set value [getConf $option]
   appendNoDupToList value {*}$args
   setConf $option $value
}

# Source site config which can be used to define global procedures or
# settings. We first look for the global siteconfig, then if an extra
# siteconfig is defined and allowed, source that file if it exists
proc sourceSiteConfig {} {
   lappend siteconfiglist [getConf siteconfig]
   for {set i 0} {$i < [llength $siteconfiglist]} {incr i} {
      set siteconfig [lindex $siteconfiglist $i]
      if {[file readable $siteconfig]} {
         reportDebug "Source site configuration ($siteconfig)"
         if {[catch {uplevel 1 source $siteconfig} errMsg]} {
            set errMsg "Site configuration source failed\n"
            # issue line number is lost due to uplevel use
            append errMsg [formatErrStackTrace $::errorInfo $siteconfig {}]
            reportErrorAndExit $errMsg
         }
         if {$siteconfig eq [getConf siteconfig]} {
            setState siteconfig_loaded 1
         } else {
            setState extra_siteconfig_loaded 1
         }
      }
      # check on extra_siteconfig after initial siteconfig loaded in case
      # it inhibits this extra load
      if {$siteconfig eq [getConf siteconfig] && [getConf\
         extra_siteconfig] ne {}} {
         lappend siteconfiglist [getConf extra_siteconfig]
      }
   }
}

# Used to tell if a machine is running Windows or not
proc initStateIsWin {} {
   return [expr {$::tcl_platform(platform) eq {windows}}]
}

# Get default path separator
proc initStatePathSeparator {} {
   return [expr {[getState is_win] ? {;} : {:}}]
}

# Detect if terminal is attached to stderr message channel
proc initStateIsStderrTty {} {
   return [expr {![catch {fconfigure stderr -mode}]}]
}

# Determine if pagination need to be started
proc initStatePaginate {} {
   set pager [getConf pager]
   # empty or 'cat' pager command means no-pager
   set no_cmds [list {} cat]
   # default pager enablement depends on pager command value
   set paginate [expr {[file tail [lindex $pager 0]] ni $no_cmds}]

   # asked enablement could only nullify a previous asked disablement as it
   # requires a valid pager command configuration, which by default enables
   # pagination; some module command may also turn off pager; also if error
   # stream is not attached to a terminal
   set no_subcmds [list clear edit]
   if {$paginate && (([info exists ::asked_paginate] && !$::asked_paginate)\
      || [getState subcmd] in $no_subcmds || ([getState subcmd] eq {ml} &&\
      [lindex [getState subcmd_args] 0] in $no_subcmds) || ![getState\
      is_stderr_tty])} {
      set paginate 0
   }

   return $paginate
}

# start pager pipe process with defined configuration
proc initStateReportfd {} {
   # get default value
   lassign $::g_state_defs(reportfd) reportfd

   # start pager at first call and only if enabled
   if {[getState paginate]} {
      if {[catch {
         set reportfd [open "|[getConf pager] >@stderr 2>@stderr" w]
         fconfigure $reportfd -buffering line -blocking 1 -buffersize 65536
      } errMsg]} {
         # silently set reportfd to its fallback value to process warn msg
         set ::g_states(reportfd) $reportfd
         reportWarning $errMsg
      }
   }

   # startup content in case of structured output format (puts here rather
   # calling report proc to avoid infinite reportfd init loop
   if {[isStateEqual report_format json]} {
      puts -nonewline $reportfd \{
   }

   return $reportfd
}

# Provide columns number for output formatting
proc initStateTermColumns {} {
   set cols [getConf term_width]
   if {$cols == 0} {
      # determine col number from tty capabilites
      # tty info query depends on running OS
      switch -- $::tcl_platform(os) {
         SunOS {
            catch {regexp {columns = (\d+);} [exec stty] match cols} errMsg
         }
         {Windows NT} {
            catch {regexp {Columns:\s+(\d+)} [exec mode] match cols} errMsg
         }
         default {
            catch {set cols [lindex [exec stty size] 1]} errMsg
         }
      }
      # default size if tty cols cannot be found
      set cols [expr {![info exists cols] || $cols eq {0} ? 80 : $cols}]
   }
   return $cols
}

# Get all groups of user running modulecmd.tcl process
proc __initStateUsergroups {} {
   # ensure groups including space in their name (found on Cygwin/MSYS
   # platforms) are correctly set as list element
   if {[catch {
      return [split [string range [runCommand id -G -n -z] 0 end-1] \0]
   } errMsg]} {
      # fallback if '-z' option is not supported
      return [runCommand id -G -n]
   }
}

# Get name of user running modulecmd.tcl process
proc __initStateUsername {} {
   return [runCommand id -u -n]
}

# Get Epoch time (number of seconds elapsed since Unix epoch)
proc __initStateClockSeconds {} {
   return [clock seconds]
}

# Know if Tcl version is below 8.5.0
proc initStateTclVersionLt85 {} {
   return [expr {[versioncmp [getState tcl_version] 8.5.0] == -1}]
}

# Initialize Select Graphic Rendition table
proc initConfColors {envvar value validvallist intvallist} {
   # overridden value coming from environment
   if {[info exists ::env($envvar)]} {
      set colors_list $::env($envvar)
      if {[catch {
         # test overridden value could be set to a dummy array variable
         array set test_colors [split $colors_list {:=}]
      } errMsg ]} {
         # report issue as a debug message rather warning to avoid
         # disturbing user with a warning message in the middle of a
         # useful output as this table will be initialized at first use
         reportDebug "Ignore invalid value set in $envvar ($colors_list)"
         unset colors_list
      }
   }

   # if no valid override set use default color theme for terminal
   # background color kind (light or dark)
   if {![info exists colors_list]} {
      if {[getConf term_background] eq {light}} {
         set colors_list {@lightbgcolors@}
      } else {
         set colors_list {@darkbgcolors@}
      }
      if {[catch {
         array set test_colors [split $colors_list {:=}]
      } errMsg ]} {
         reportDebug "Ignore invalid default [getConf term_background]\
            background colors ($colors_list)"
         # define an empty list if no valid value set
         set colors_list {}
      }
   }

   # check each color defined and unset invalid codes
   set value {}
   foreach {elt col} [split $colors_list {:=}] {
      if {![regexp {^[\d;]+$} $col]} {
         reportDebug "Ignore invalid color code for '$elt' ($col)"
      } else {
         lappend value $elt=$col
      }
   }
   set value [join $value :]

   # set SGR table as an array to easily access rendition for each key
   array unset ::g_colors
   array set ::g_colors [split $value {:=}]

   return $value
}

# Initialize color configuration value
proc initConfColor {envvar value validvallist intvallist} {
   # overridden value coming from environment via standard variable
   # https://no-color.org/ and https://bixense.com/clicolors/
   if {[info exists ::env(NO_COLOR)]} {
      set value never
   } elseif {[info exists ::env(CLICOLOR)]} {
      if {$::env(CLICOLOR) eq {0}} {
         set value never
      } else {
         set value auto
      }
   } elseif {[info exists ::env(CLICOLOR_FORCE)] && $::env(CLICOLOR_FORCE)\
      ne {0}} {
      set value always
   }

   # overridden value coming from environment via Modules-specific variable
   if {$envvar ne {} && [info exists ::env($envvar)]} {
      # ignore non-valid values
      if {[llength $validvallist] == 0 || $::env($envvar) in $validvallist} {
         set value $::env($envvar)
      }
   }

   # overridden value coming the command-line
   if {[info exists ::asked_color]} {
      set value [set ::asked_color]
   }

   # convert value to its internal representation
   if {[llength $intvallist] > 0} {
      set value [lindex $intvallist [lsearch -exact $validvallist $value]]
   }

   # disable color mode if no terminal attached except if 'always' asked
   if {$value != 0 && (![getState is_stderr_tty] || $value == 2)} {
      incr value -1
   }

   # initialize color theme if color mode enabled
   getConf colors

   return $value
}

# Initialize tcl_ext_lib configuration value
proc initConfTclExtLib {envvar value validvallist intvallist} {
   set libfile libtclenvmodules@SHLIB_SUFFIX@

   # determine lib directory
   @notmultilibsupport@set libdir @libdir@
   @multilibsupport@switch -- [getState machine] {
   @multilibsupport@   x86_64 - aarch64 - ppc64le - s390x {
   @multilibsupport@      set libdirmain @libdir64@
   @multilibsupport@      set libdiralt @libdir32@
   @multilibsupport@   }
   @multilibsupport@   default {
   @multilibsupport@      set libdirmain @libdir32@
   @multilibsupport@      set libdiralt @libdir64@
   @multilibsupport@   }
   @multilibsupport@}
   @multilibsupport@# use alternative arch lib if available and not main one
   @multilibsupport@if {![file exists [file join $libdirmain $libfile]] && [file exists [file\
   @multilibsupport@   join $libdiralt $libfile]]} {
   @multilibsupport@   set libdir $libdiralt
   @multilibsupport@} else {
   @multilibsupport@   set libdir $libdirmain
   @multilibsupport@}

   return [file join $libdir $libfile]
}

# Initialize module tag abbreviation table
proc initConfTagAbbrev {envvar value validvallist intvallist} {
   # overridden value coming from environment
   if {[info exists ::env($envvar)]} {
      if {[catch {
         # try to set the tag-abbreviation mapping table
         array set ::g_tagAbbrev [split $::env($envvar) {:=}]
         set value $::env($envvar)
      } errMsg ]} {
         reportWarning "Ignore invalid value set in $envvar ($::env($envvar))"
         array unset ::g_tagAbbrev
      }
   }

   # test default value
   if {![array exists ::g_tagAbbrev]} {
      if {[catch {
         array set ::g_tagAbbrev [split $value {:=}]
      } errMsg ]} {
         reportWarning "Ignore invalid default value for 'tag_abbrev' config\
            ($value)"
         array unset ::g_tagAbbrev
         # define an empty list if no valid value set
         set value {}
      }
   }

   # build abbrev:tagname array
   foreach {tag abbrev} [array get ::g_tagAbbrev] {
      # skip tags not relevant for current command, that share their
      # abbreviation with another tag
      switch -- $tag {
         hidden-loaded {
            set setabbrevtag [expr {[currentState commandname] eq {list}}]
         }
         hidden {
            set setabbrevtag [expr {[currentState commandname] eq {avail}}]
         }
         default {
            set setabbrevtag 1
         }
      }
      if {$setabbrevtag} {
         set ::g_abbrevTag($abbrev) $tag
      }
   }

   return $value
}

# Initialize module tag color name table
proc initConfTagColorName {envvar value validvallist intvallist} {
   # overridden value coming from environment
   if {[info exists ::env($envvar)]} {
      set value $::env($envvar)
   }

   # set table for efficient search
   foreach tag [split $value :] {
      set ::g_tagColorName($tag) 1
   }

   return $value
}

# Initialize interactive editor command
proc initConfEditor {envvar value validvallist intvallist} {
   # overridden value coming from environment via Modules-specific variable
   if {$envvar ne {} && [info exists ::env($envvar)]} {
      set value $::env($envvar)
   # overridden value coming from environment via standard variable
   } elseif {[info exists ::env(VISUAL)]} {
      set value $::env(VISUAL)
   } elseif {[info exists ::env(EDITOR)]} {
      set value $::env(EDITOR)
   }
   return $value
}

# Initialize variant shortcut table
proc initConfVariantShortcut {envvar value validvallist intvallist} {
   # overridden value coming from environment
   if {[info exists ::env($envvar)]} {
      if {[catch {
         # try to set the variant-shortcut mapping table
         array set testarr [split $::env($envvar) {:=}]
         set value $::env($envvar)
         set setfromenv 1
      } errMsg ]} {
         reportWarning "Ignore invalid value set in $envvar ($::env($envvar))"
      }
   }

   # test default value
   if {![info exists setfromenv]} {
      if {[catch {
         array set testarr [split $value {:=}]
      } errMsg ]} {
         reportWarning "Ignore invalid default value for 'variant_shortcut'\
            config ($value)"
         # define an empty list if no valid value set
         set value {}
      }
   }

   # ignore shortcut if not equal to one character or if set on alphanum char
   # or on char with special meaning
   foreach {vr sc} [split $value {:=}] {
      if {[string length $sc] == 1 && ![string match {[a-zA-Z0-9+~/@=-]}\
         $sc]} {
         # remove duplicate shortcut or variant definition
         if {[info exists ::g_variantShortcut($vr)]} {
            unset ::g_shortcutVariant($::g_variantShortcut($vr))
         }
         if {[info exists ::g_shortcutVariant($sc)]} {
            unset ::g_variantShortcut($::g_shortcutVariant($sc))
         }
         set ::g_variantShortcut($vr) $sc
         set ::g_shortcutVariant($sc) $vr
      }
   }

   # update value after above filtering step
   set value {}
   foreach vr [array names ::g_variantShortcut] {
      if {[string length $value] > 0} {
         append value :
      }
      append value $vr=$::g_variantShortcut($vr)
   }

   return $value
}

# Is currently set verbosity level is equal or higher than level passed as arg
proc isVerbosityLevel {name} {
   return [expr {[lsearch -exact [lindex $::g_config_defs(verbosity) 3]\
      [getConf verbosity]] >= [lsearch -exact [lindex\
      $::g_config_defs(verbosity) 3] $name]}]
}

# Is match performed in a case sensitive or insensitive manner
proc isIcase {} {
   # depending on current sub-command, list values that equal to a case
   # insensitive match enablement
   lappend enabledValList always
   if {[currentState commandname] in [list avail whatis search paths]} {
      lappend enabledValList search
   }
   return [expr {[getConf icase] in $enabledValList}]
}


##############################################################################
# Utilities ------------------------------------------------------------------
##############################################################################

proc charEscaped {str {charlist { \\\t\{\}|<>!;#^$&*?"'`()}}} {
   return [regsub -all "\(\[$charlist\]\)" $str {\\\1}]
}

proc charUnescaped {str {charlist { \\\t\{\}|<>!;#^$&*?"'`()}}} {
   return [regsub -all "\\\\\(\[$charlist\]\)" $str {\1}]
}

proc strTo {lang str {esc 1}} {
   switch -- $lang {
      tcl { set enco \{; set encc \}}
      shell { set enco '; set encc '}
   }
   # escape all special characters
   if {$esc} {
      set str [charEscaped $str]
   }
   # enclose if empty or if contain a space character unless already escaped
   if {$str eq {} || (!$esc && [regexp {\s} $str])} {
      set str "$enco$str$encc"
   }
   return $str
}

proc listTo {lang lst {esc 1}} {
   set lout [list]
   # transform each list element
   foreach str $lst {
      lappend lout [strTo $lang $str $esc]
   }
   return [join $lout { }]
}

# find command path and remember it
proc getCommandPath {cmd} {
   return [lindex [auto_execok $cmd] 0]
}

# find then run command or raise error if command not found
proc runCommand {cmd args} {
   set cmdpath [getCommandPath $cmd]
   if {$cmdpath eq {}} {
      knerror "Command '$cmd' cannot be found" MODULES_ERR_GLOBAL
   } else {
      return [exec $cmdpath {*}$args]
   }
}

proc getAbsolutePath {path} {
   # currently executing a modulefile or rc, so get the directory of this file
   if {[currentState modulefile] ne {}} {
      set curdir [file dirname [currentState modulefile]]
   # elsewhere get module command current working directory
   } else {
      # register pwd at first call
      if {![isStateDefined cwd]} {
         setState cwd [pwd]
      }
      set curdir [getState cwd]
   }

   # empty result if empty path
   if {$path eq {}} {
      set abspath {}
   # consider path absolute if it starts with a variable ref
   } elseif {[string index $path 0] eq {$}} {
      set abspath $path
   } else {
      set abslist {}
      # get a first version of the absolute path by joining the current
      # working directory to the given path. if given path is already absolute
      # 'file join' will not break it as $curdir will be ignored as soon a
      # beginning '/' character is found on $path. this first pass also clean
      # extra '/' character. then each element of the path is analyzed to
      # clear "." and ".." components.
      foreach elt [file split [file join $curdir $path]] {
         if {$elt eq {..}} {
            # skip ".." element if it comes after root element, remove last
            # element elsewhere
            if {[llength $abslist] > 1} {
               set abslist [lreplace $abslist end end]
            }
         # skip any "." element
         } elseif {$elt ne {.}} {
            lappend abslist $elt
         }
      }
      set abspath [file join {*}$abslist]
   }

   # return cleaned absolute path
   return $abspath
}

# if no exact match found but icase mode is enabled then search if an icase
# match exists among all array key elements, select dictionary highest version
# if multiple icase matches are returned
proc getArrayKey {arrname name icase} {
   if {$icase} {
      upvar $arrname arr
      if {![info exists arr($name)]} {
         foreach elt [lsort -dictionary -decreasing [array names arr]] {
            if {[string equal -nocase $name $elt]} {
               reportDebug "key '$elt' in array '$arrname' matches '$name'"
               set name $elt
               break
            }
         }
      }
   }
   return $name
}

# split string while ignore any separator character that is escaped
proc psplit {str sep} {
   # use standard split if no sep character found
   if {[string first \\$sep $str] == -1} {
      set res [split $str $sep]
   } else {
      set previdx -1
      set idx [string first $sep $str]
      while {$idx != -1} {
         # look ahead if found separator is escaped
         if {[string index $str [expr {$idx-1}]] ne "\\"} {
            # unescape any separator character when adding to list
            lappend res [charUnescaped [string range $str [expr {$previdx+1}]\
               [expr {$idx-1}]] $sep]
            set previdx $idx
         }
         set idx [string first $sep $str [expr {$idx+1}]]
      }

      lappend res [charUnescaped [string range $str [expr {$previdx+1}] end]\
         $sep]
   }

   return $res
}

# join list while escape any character equal to separator
proc pjoin {lst sep} {
   # use standard join if no sep character found
   if {[string first $sep $lst] == -1} {
      set res [join $lst $sep]
   } else {
      set res {}
      foreach elt $lst {
         # preserve empty entries
         if {[info exists not_first]} {
            append res $sep
         } else {
            set not_first 1
         }
         # escape any separator character when adding to string
         append res [charEscaped $elt $sep]
      }
   }

   return $res
}

# Is provided string a version number: consider first element of string if
# '.' character used in it. [0-9af] on this first part is considered valid
# anything else could be used in latter elements
proc isVersion {str} {
   return [string is xdigit -strict [lindex [split $str .] 0]]
}

# Return number of occurrences of passed character in passed string
proc countChar {str char} {
   return [expr {[string length $str] - [string length [string map [list\
      $char {}] $str]]}]
}

proc appendNoDupToList {lstname args} {
   set ret 0
   upvar $lstname lst
   foreach elt $args {
      if {![info exists lst] || $elt ni $lst} {
         lappend lst $elt
         set ret 1
      }
   }
   return $ret
}

proc replaceFromList {list1 item {item2 {}}} {
    while {[set xi [lsearch -exact $list1 $item]] >= 0} {
       set list1 [if {[string length $item2] == 0} {lreplace $list1 $xi $xi}\
         {lreplace $list1 $xi $xi $item2}]
    }

    return $list1
}

# test if 2 lists have at least one element in common
proc isIntBetweenList {list1 list2} {
   foreach elt $list1 {
      if {$elt in $list2} {
         return 1
      }
   }
   return 0
}

# test if 2 lists have at least one element in diff
proc isDiffBetweenList {list1 list2} {
   foreach elt $list1 {
      if {$elt ni $list2} {
         return 1
      }
   }
   return 0
}

# returns elements from list1 not part of list2 and elements from list2 not
# part of list1
proc getDiffBetweenList {list1 list2} {
   set res1 [list]
   set res2 [list]

   foreach elt $list1 {
      if {$elt ni $list2} {
         lappend res1 $elt
      }
   }
   foreach elt $list2 {
      if {$elt ni $list1} {
         lappend res2 $elt
      }
   }

   return [list $res1 $res2]
}

# return elements from arr1 not in arr2, elements from arr1 in arr2 but with a
# different value and elements from arr2 not in arr1
proc getDiffBetweenArray {arrname1 arrname2} {
   upvar $arrname1 arr1
   upvar $arrname2 arr2
   set notin2 [list]
   set diff [list]
   set notin1 [list]

   foreach name [array names arr1] {
      # element in arr1 not in arr2
      if {![info exists arr2($name)]} {
         lappend notin2 $name
      # element present in both arrays but with a different value
      } elseif {$arr1($name) ne $arr2($name)} {
         lappend diff $name
      }
   }

   foreach name [array names arr2] {
      # element in arr2 not in arr1
      if {![info exists arr1($name)]} {
         lappend notin1 $name
      }
   }

   return [list $notin2 $diff $notin1]
}


##############################################################################
# Environment management -----------------------------------------------------
##############################################################################

proc raiseErrorCount {} {
   setState error_count [expr {[getState error_count] + 1}]
}

proc renderFalse {} {
   if {[isStateDefined false_rendered]} {
      reportDebug {false already rendered}
   } elseif {[isStateDefined shelltype]} {
      # setup flag to render only once
      setState false_rendered 1

      # render a false value most of the time through a variable assignment
      # that will be looked at in the shell module function calling
      # modulecmd.tcl to return in turns a boolean status. Except for python
      # and cmake, the value assigned to variable is also returned as the
      # entire rendering status
      switch -- [getState shelltype] {
         sh - csh - fish {
            # no need to set a variable on real shells as last statement
            # result can easily be checked
            puts stdout {test 0 = 1;}
         }
         tcl {
            puts stdout {set _mlstatus 0;}
         }
         cmd {
            puts stdout {set errorlevel=1}
         }
         perl {
            puts stdout {{ no strict 'vars'; $_mlstatus = 0; }}
         }
         python {
            puts stdout {_mlstatus = False}
         }
         ruby {
            puts stdout {_mlstatus = false}
         }
         lisp {
            puts stdout {nil}
         }
         cmake {
            puts stdout {set(_mlstatus FALSE)}
         }
         r {
            puts stdout {mlstatus <- FALSE}
         }
      }
   }
}

proc renderTrue {} {
   reportDebug called.

   # render a true value most of the time through a variable assignment that
   # will be looked at in the shell module function calling modulecmd.tcl to
   # return in turns a boolean status. Except for python and cmake, the
   # value assigned to variable is also returned as the full rendering status
   switch -- [getState shelltype] {
      sh - csh - fish {
         # no need to set a variable on real shells as last statement
         # result can easily be checked
         puts stdout {test 0;}
      }
      tcl {
         puts stdout {set _mlstatus 1;}
      }
      cmd {
         puts stdout {set errorlevel=0}
      }
      perl {
         puts stdout {{ no strict 'vars'; $_mlstatus = 1; }}
      }
      python {
         puts stdout {_mlstatus = True}
      }
      ruby {
         puts stdout {_mlstatus = true}
      }
      lisp {
         puts stdout {t}
      }
      cmake {
         puts stdout {set(_mlstatus TRUE)}
      }
      r {
         puts stdout {mlstatus <- TRUE}
      }
   }
}

proc renderText {text} {
   reportDebug "called ($text)."

   # render a text value most of the time through a variable assignment that
   # will be looked at in the shell module function calling modulecmd.tcl to
   # return in turns a string value.
   switch -- [getState shelltype] {
      sh - csh - fish {
         foreach word $text {
            # no need to set a variable on real shells, echoing text will make
            # it available as result
            puts stdout "echo '$word';"
         }
      }
      tcl {
         puts stdout "set _mlstatus \"$text\";"
      }
      cmd {
         foreach word $text {
            puts stdout "echo $word"
         }
      }
      perl {
         puts stdout "{ no strict 'vars'; \$_mlstatus = '$text'; }"
      }
      python {
         puts stdout "_mlstatus = '$text'"
      }
      ruby {
         puts stdout "_mlstatus = '$text'"
      }
      lisp {
         puts stdout "(message \"$text\")"
      }
      cmake {
         puts stdout "set(_mlstatus \"$text\")"
      }
      r {
         puts stdout "mlstatus <- '$text'"
      }
   }
}

proc renderSettings {} {
   global g_stateEnvVars g_stateAliases g_stateFunctions g_newXResources\
      g_delXResources

   reportDebug called.

   # required to work on cygwin, shouldn't hurt real linux
   fconfigure stdout -translation lf

   # preliminaries if there is stuff to render
   if {[getState autoinit] || [array size g_stateEnvVars] > 0 ||\
      [array size g_stateAliases] > 0 || [array size g_newXResources] > 0 ||\
      [array size g_stateFunctions] > 0 || [array size g_delXResources] > 0\
      || [info exists ::g_changeDir] || [info exists ::g_stdoutPuts] ||\
      [info exists ::g_return_text]} {
      switch -- [getState shelltype] {
         python {
            puts stdout {import os}
         }
      }
      set has_rendered 1
   } else {
      set has_rendered 0
   }

   if {[getState autoinit]} {
      renderAutoinit
   }

   # new environment variables
   foreach var [array names g_stateEnvVars] {
      switch -- $g_stateEnvVars($var) {
         new {
            switch -- [getState shelltype] {
               csh {
                  set val [charEscaped $::env($var)]
                  # csh barfs on long env vars
                  if {[getState shell] eq {csh} && [string length $val] >\
                     [getConf csh_limit]} {
                     if {$var eq {PATH}} {
                        reportWarning "PATH exceeds [getConf csh_limit]\
                           characters, truncating and appending\
                           /usr/bin:/bin ..."
                        set val [string range $val 0 [expr {[getConf\
                           csh_limit] - 1}]]:/usr/bin:/bin
                     } else {
                        reportWarning "$var exceeds [getConf csh_limit]\
                           characters, truncating..."
                         set val [string range $val 0 [expr {[getConf\
                           csh_limit]  - 1}]]
                     }
                  }
                  puts stdout "setenv $var $val;"
               }
               sh {
                  puts stdout "$var=[charEscaped $::env($var)];\
                     export $var;"
               }
               fish {
                  set val [charEscaped $::env($var)]
                  # fish shell has special treatment for PATH variable
                  # so its value should be provided as a list separated
                  # by spaces not by semi-colons
                  if {$var eq {PATH}} {
                     regsub -all : $val { } val
                  }
                  puts stdout "set -xg $var $val;"
               }
               tcl {
                  set val $::env($var)
                  puts stdout "set ::env($var) {$val};"
               }
               cmd {
                  set val $::env($var)
                  puts stdout "set $var=$val"
               }
               perl {
                  set val [charEscaped $::env($var) \']
                  puts stdout "\$ENV{'$var'} = '$val';"
               }
               python {
                  set val [charEscaped $::env($var) \']
                  puts stdout "os.environ\['$var'\] = '$val'"
               }
               ruby {
                  set val [charEscaped $::env($var) \']
                  puts stdout "ENV\['$var'\] = '$val'"
               }
               lisp {
                  set val [charEscaped $::env($var) \"]
                  puts stdout "(setenv \"$var\" \"$val\")"
               }
               cmake {
                  set val [charEscaped $::env($var) \"]
                  puts stdout "set(ENV{$var} \"$val\")"
               }
               r {
                  set val [charEscaped $::env($var) {\\'}]
                  puts stdout "Sys.setenv('$var'='$val')"
               }
            }
         }
         del {
            switch -- [getState shelltype] {
               csh {
                  puts stdout "unsetenv $var;"
               }
               sh {
                  puts stdout "unset $var;"
               }
               fish {
                  puts stdout "set -e $var;"
               }
               tcl {
                  puts stdout "catch {unset ::env($var)};"
               }
               cmd {
                  puts stdout "set $var="
               }
               perl {
                  puts stdout "delete \$ENV{'$var'};"
               }
               python {
                  puts stdout "os.environ\['$var'\] = ''"
                  puts stdout "del os.environ\['$var'\]"
               }
               ruby {
                  puts stdout "ENV\['$var'\] = nil"
               }
               lisp {
                  puts stdout "(setenv \"$var\" nil)"
               }
               cmake {
                  puts stdout "unset(ENV{$var})"
               }
               r {
                  puts stdout "Sys.unsetenv('$var')"
               }
            }
         }
      }
   }

   foreach var [array names g_stateAliases] {
      switch -- $g_stateAliases($var) {
         new {
            set val $::g_Aliases($var)
            # convert $n in !!:n and $* in !* on csh (like on compat version)
            if {[getState shelltype] eq {csh}} {
               regsub -all {([^\\]|^)\$([0-9]+)} $val {\1!!:\2} val
               regsub -all {([^\\]|^)\$\*} $val {\1!*} val
            }
            # unescape \$ after now csh-specific conversion is over
            regsub -all {\\\$} $val {$} val
            switch -- [getState shelltype] {
               csh {
                  set val [charEscaped $val]
                  puts stdout "alias $var $val;"
               }
               sh {
                  set val [charEscaped $val]
                  puts stdout "alias $var=$val;"
               }
               fish {
                  set val [charEscaped $val]
                  puts stdout "alias $var $val;"
               }
               cmd {
                  puts stdout "doskey $var=$val"
               }
            }
         }
         del {
            switch -- [getState shelltype] {
               csh {
                  puts stdout "unalias $var;"
               }
               sh {
                  puts stdout "unalias $var;"
               }
               fish {
                  puts stdout "functions -e $var;"
               }
               cmd {
                  puts stdout "doskey $var="
               }
            }
         }
      }
   }
   foreach funcname [array names g_stateFunctions] {
      switch -- $g_stateFunctions($funcname) {
         new {
            # trim function body to smoothly add a finishing ;
            set val [string trim $::g_Functions($funcname) "; \t\n\r"]
            switch -- [getState shell] {
               sh - ksh - zsh {
                  puts stdout "$funcname () { $val; };"
               }
               bash {
                  puts stdout "$funcname () { $val; }; export -f $funcname;"
               }
               fish {
                  puts stdout "function $funcname; $val; end;"
               }
            }
         }
         del {
            switch -- [getState shelltype] {
               sh {
                  puts stdout "unset -f $funcname;"
               }
               fish {
                  puts stdout "functions -e $funcname;"
               }
            }
         }
      }
   }

   # preliminaries for x-resources stuff
   if {[array size g_newXResources] > 0 || [array size g_delXResources] > 0} {
      switch -- [getState shelltype] {
         python {
            puts stdout {import subprocess}
         }
         ruby {
            puts stdout {require 'open3'}
         }
      }
   }

   # new x resources
   if {[array size g_newXResources] > 0} {
      # xrdb executable has already be verified in x-resource
      set xrdb [getCommandPath xrdb]
      foreach var [array names g_newXResources] {
         set val $g_newXResources($var)
         # empty val means that var is a file to parse
         if {$val eq {}} {
            switch -- [getState shelltype] {
               sh - csh - fish {
                  puts stdout "$xrdb -merge $var;"
               }
               tcl {
                  puts stdout "exec $xrdb -merge $var;"
               }
               perl {
                  puts stdout "system(\"$xrdb -merge $var\");"
               }
               python {
                  set var [charEscaped $var \']
                  puts stdout "subprocess.Popen(\['$xrdb',\
                     '-merge', '$var'\])"
               }
               ruby {
                  set var [charEscaped $var \']
                  puts stdout "Open3.popen2('$xrdb -merge $var')"
               }
               lisp {
                  puts stdout "(shell-command-to-string \"$xrdb\
                     -merge $var\")"
               }
               cmake {
                  puts stdout "execute_process(COMMAND $xrdb -merge $var)"
               }
               r {
                  set var [charEscaped $var {\\'}]
                  puts stdout "system('$xrdb -merge $var')"
               }
            }
         } else {
            switch -- [getState shelltype] {
               sh - csh - fish {
                  set var [charEscaped $var \"]
                  set val [charEscaped $val \"]
                  puts stdout "echo \"$var: $val\" | $xrdb -merge;"
               }
               tcl {
                  puts stdout "set XRDBPIPE \[open \"|$xrdb -merge\" r+\];"
                  set var [charEscaped $var \"]
                  set val [charEscaped $val \"]
                  puts stdout "puts \$XRDBPIPE \"$var: $val\";"
                  puts stdout {close $XRDBPIPE;}
                  puts stdout {unset XRDBPIPE;}
               }
               perl {
                  puts stdout "open(XRDBPIPE, \"|$xrdb -merge\");"
                  set var [charEscaped $var \"]
                  set val [charEscaped $val \"]
                  puts stdout "print XRDBPIPE \"$var: $val\\n\";"
                  puts stdout {close XRDBPIPE;}
               }
               python {
                  set var [charEscaped $var \']
                  set val [charEscaped $val \']
                  puts stdout "subprocess.Popen(\['$xrdb', '-merge'\],\
                     stdin=subprocess.PIPE).communicate(input='$var:\
                     $val\\n')"
               }
               ruby {
                  set var [charEscaped $var \']
                  set val [charEscaped $val \']
                  puts stdout "Open3.popen2('$xrdb -merge') {|i,o,t| i.puts\
                     '$var: $val'}"
               }
               lisp {
                  puts stdout "(shell-command-to-string \"echo $var:\
                     $val | $xrdb -merge\")"
               }
               cmake {
                  set var [charEscaped $var \"]
                  set val [charEscaped $val \"]
                  puts stdout "execute_process(COMMAND echo \"$var: $val\"\
                     COMMAND $xrdb -merge)"
               }
               r {
                  set var [charEscaped $var {\\'}]
                  set val [charEscaped $val {\\'}]
                  puts stdout "system('$xrdb -merge', input='$var: $val')"
               }
            }
         }
      }
   }

   if {[array size g_delXResources] > 0} {
      set xrdb [getCommandPath xrdb]
      set xres_to_del {}
      foreach var [array names g_delXResources] {
         # empty val means that var is a file to parse
         if {$g_delXResources($var) eq {}} {
            # xresource file has to be parsed to find what resources
            # are declared there and need to be unset
            foreach fline [split [exec $xrdb -n load $var] \n] {
               lappend xres_to_del [lindex [split $fline :] 0]
            }
         } else {
            lappend xres_to_del $var
         }
      }

      # xresource strings are unset by emptying their value since there
      # is no command of xrdb that can properly remove one property
      switch -- [getState shelltype] {
         sh - csh - fish {
            foreach var $xres_to_del {
               puts stdout "echo \"$var:\" | $xrdb -merge;"
            }
         }
         tcl {
            foreach var $xres_to_del {
               puts stdout "set XRDBPIPE \[open \"|$xrdb -merge\" r+\];"
               set var [charEscaped $var \"]
               puts stdout "puts \$XRDBPIPE \"$var:\";"
               puts stdout {close $XRDBPIPE;}
               puts stdout {unset XRDBPIPE;}
            }
         }
         perl {
            foreach var $xres_to_del {
               puts stdout "open(XRDBPIPE, \"|$xrdb -merge\");"
               set var [charEscaped $var \"]
               puts stdout "print XRDBPIPE \"$var:\\n\";"
               puts stdout {close XRDBPIPE;}
            }
         }
         python {
            foreach var $xres_to_del {
               set var [charEscaped $var \']
               puts stdout "subprocess.Popen(\['$xrdb', '-merge'\],\
                  stdin=subprocess.PIPE).communicate(input='$var:\\n')"
            }
         }
         ruby {
            foreach var $xres_to_del {
               set var [charEscaped $var \']
               puts stdout "Open3.popen2('$xrdb -merge') {|i,o,t| i.puts\
                  '$var:'}"
            }
         }
         lisp {
            foreach var $xres_to_del {
               puts stdout "(shell-command-to-string \"echo $var: |\
                  $xrdb -merge\")"
            }
         }
         cmake {
            foreach var $xres_to_del {
               set var [charEscaped $var \"]
               puts stdout "execute_process(COMMAND echo \"$var:\"\
                  COMMAND $xrdb -merge)"
            }
         }
         r {
            foreach var $xres_to_del {
               set var [charEscaped $var {\\'}]
               puts stdout "system('$xrdb -merge', input='$var:')"
            }
         }
      }
   }

   if {[info exists ::g_changeDir]} {
      switch -- [getState shelltype] {
         sh - csh - fish {
            puts stdout "cd '$::g_changeDir';"
         }
         tcl {
            puts stdout "cd \"$::g_changeDir\";"
         }
         cmd {
            puts stdout "cd $::g_changeDir"
         }
         perl {
            puts stdout "chdir '$::g_changeDir';"
         }
         python {
            puts stdout "os.chdir('$::g_changeDir')"
         }
         ruby {
            puts stdout "Dir.chdir('$::g_changeDir')"
         }
         lisp {
            puts stdout "(shell-command-to-string \"cd '$::g_changeDir'\")"
         }
         r {
            puts stdout "setwd('$::g_changeDir')"
         }
      }
      # cannot change current directory of cmake "shell"
   }

   # send content deferred during modulefile interpretation
   if {[info exists ::g_stdoutPuts]} {
      foreach putsArgs $::g_stdoutPuts {
         puts {*}$putsArgs
         # check if a finishing newline will be needed after content sent
         set needPutsNl [expr {[lindex $putsArgs 0] eq {-nonewline}}]
      }
      if {$needPutsNl} {
         puts stdout {}
      }
   }

   # return text value if defined even if error happened
   if {[info exists ::g_return_text]} {
      reportDebug {text value should be returned.}
      renderText $::g_return_text
   } elseif {[getState error_count] > 0} {
      reportDebug "[getState error_count] error(s) detected."
      renderFalse
   } elseif {[getState return_false]} {
      reportDebug {false value should be returned.}
      renderFalse
   } elseif {$has_rendered} {
      # finish with true statement if something has been put
      renderTrue
   }
}

proc renderAutoinit {} {
   reportDebug called.

   # automatically detect which tclsh should be used for
   # future module commands
   set tclshbin [info nameofexecutable]

   # ensure script path is absolute
   set ::argv0 [getAbsolutePath $::argv0]

   switch -- [getState shelltype] {
      csh {
         set pre_hi {set _histchars = $histchars; unset histchars;}
         set post_hi {set histchars = $_histchars; unset _histchars;}
         set pre_pr {set _prompt=$prompt:q; set prompt="";}
         set post_pr {set prompt=$_prompt:q; unset _prompt;}
         # apply workaround for Tcsh history if set
         set eval_cmd [expr {[getConf wa_277] ? "eval `$tclshbin $::argv0\
            [getState shell] \\!*`;" :  "eval \"`$tclshbin $::argv0 [getState\
            shell] \\!*:q`\";"}]
         set pre_ex {set _exit="$status";}
         set post_ex {test 0 = $_exit}

         set fdef "if ( \$?histchars && \$?prompt )\
alias module '$pre_hi $pre_pr $eval_cmd $pre_ex $post_hi $post_pr $post_ex' ;
if ( \$?histchars && ! \$?prompt )\
alias module '$pre_hi $eval_cmd $pre_ex $post_hi $post_ex' ;
if ( ! \$?histchars && \$?prompt )\
alias module '$pre_pr $eval_cmd $pre_ex $post_pr $post_ex' ;
if ( ! \$?histchars && ! \$?prompt ) alias module '$eval_cmd' ;"
         if {[getConf ml]} {
            append fdef {
alias ml 'module ml \!*' ;}
         }
      }
      sh {
         # Considering the diversity of ways local variables are handled
         # through the sh-variants ('local' known everywhere except on ksh,
         # 'typeset' known everywhere except on pure-sh, and on some systems
         # the pure-sh is in fact a 'ksh'), no local variables are defined and
         # these variables that should have been local are unset at the end

         # on zsh, word splitting should be enabled explicitly
         set wsplit [expr {[getState shell] eq {zsh} ? {^^=} : {}}]
         # only redirect module from stderr to stdout when session is
         # attached to a terminal to avoid breaking non-terminal session
         # (scp, sftp, etc)
         set fname [expr {[getState is_stderr_tty] ? {_module_raw} : {module}}]
         # build quarantine mechanism in module function
         # an empty runtime variable is set even if no corresponding
         # MODULES_RUNENV_* variable found, as var cannot be unset on
         # modified environment command-line
         set fdef "${fname}() {"
@silentshdbgsupport@         append fdef {
@silentshdbgsupport@   unset _mlshdbg;
@silentshdbgsupport@   if [ "${MODULES_SILENT_SHELL_DEBUG:-0}" = '1' ]; then
@silentshdbgsupport@      case "$-" in
@silentshdbgsupport@         *v*x*) set +vx; _mlshdbg='vx' ;;
@silentshdbgsupport@         *v*) set +v; _mlshdbg='v' ;;
@silentshdbgsupport@         *x*) set +x; _mlshdbg='x' ;;
@silentshdbgsupport@         *) _mlshdbg='' ;;
@silentshdbgsupport@      esac;
@silentshdbgsupport@   fi;}
@quarantinesupport@         append fdef "
@quarantinesupport@   unset _mlre _mlIFS;
@quarantinesupport@   if \[ -n \"\${IFS+x}\" \]; then
@quarantinesupport@      _mlIFS=\$IFS;
@quarantinesupport@   fi;
@quarantinesupport@   IFS=' ';
@quarantinesupport@   for _mlv in \${${wsplit}MODULES_RUN_QUARANTINE:-}; do"
@quarantinesupport@         append fdef {
@quarantinesupport@      if [ "${_mlv}" = "${_mlv##*[!A-Za-z0-9_]}" -a "${_mlv}" = "${_mlv#[0-9]}" ]; then
@quarantinesupport@         if [ -n "`eval 'echo ${'$_mlv'+x}'`" ]; then
@quarantinesupport@            _mlre="${_mlre:-}__MODULES_QUAR_${_mlv}='`eval 'echo ${'$_mlv'}'`' ";
@quarantinesupport@         fi;
@quarantinesupport@         _mlrv="MODULES_RUNENV_${_mlv}";
@quarantinesupport@         _mlre="${_mlre:-}${_mlv}='`eval 'echo ${'$_mlrv':-}'`' ";
@quarantinesupport@      fi;
@quarantinesupport@   done;
@quarantinesupport@   if [ -n "${_mlre:-}" ]; then}
@quarantinesupport@         append fdef "\n      eval `eval \${${wsplit}_mlre} $tclshbin $::argv0\
@quarantinesupport@[getState shell] '\"\$@\"'`;
@quarantinesupport@   else
@quarantinesupport@      eval `$tclshbin $::argv0 [getState shell] \"\$@\"`;
@quarantinesupport@   fi;"
@notquarantinesupport@         append fdef "
@notquarantinesupport@   eval `$tclshbin $::argv0 [getState shell] \"\$@\"`;"
         append fdef {
   _mlstatus=$?;}
@quarantinesupport@         append fdef {
@quarantinesupport@   if [ -n "${_mlIFS+x}" ]; then
@quarantinesupport@      IFS=$_mlIFS;
@quarantinesupport@   else
@quarantinesupport@      unset IFS;
@quarantinesupport@   fi;
@quarantinesupport@   unset _mlre _mlv _mlrv _mlIFS;}
@silentshdbgsupport@         append fdef {
@silentshdbgsupport@   if [ -n "${_mlshdbg:-}" ]; then
@silentshdbgsupport@      set -$_mlshdbg;
@silentshdbgsupport@   fi;
@silentshdbgsupport@   unset _mlshdbg;}
         append fdef {
   return $_mlstatus;}
         append fdef "\n};"
         if {[getState is_stderr_tty]} {
            append fdef "\nmodule() { _module_raw \"\$@\" 2>&1; };"
         }
         if {[getConf ml]} {
            append fdef {
ml() { module ml "$@"; };}
         }
      }
      fish {
         set fdef [expr {[getState is_stderr_tty] ? "function _module_raw\n" :\
            "function module\n"}]
@quarantinesupport@         append fdef {   set -l _mlre ''; set -l _mlv; set -l _mlrv;
@quarantinesupport@   for _mlv in (string split ' ' $MODULES_RUN_QUARANTINE)
@quarantinesupport@      if string match -r '^[A-Za-z_][A-Za-z0-9_]*$' $_mlv >/dev/null
@quarantinesupport@         if set -q $_mlv
@quarantinesupport@            set _mlre $_mlre"__MODULES_QUAR_"$_mlv"='$$_mlv' "
@quarantinesupport@         end
@quarantinesupport@         set _mlrv "MODULES_RUNENV_$_mlv"
@quarantinesupport@         set _mlre "$_mlre$_mlv='$$_mlrv' "
@quarantinesupport@      end
@quarantinesupport@   end
@quarantinesupport@   if [ -n "$_mlre" ]
@quarantinesupport@      set _mlre "env $_mlre"
@quarantinesupport@   end}
         # use "| source -" rather than "eval" to be able
         # to redirect stderr after stdout being evaluated
@quarantinesupport@         append fdef "\n   eval \$_mlre $tclshbin $::argv0 [getState shell]\
            (string escape -- \$argv) | source -\n"
@notquarantinesupport@         append fdef "   eval $tclshbin $::argv0 [getState shell]\
            (string escape -- \$argv) | source -\n"
         if {[getState is_stderr_tty]} {
            append fdef {end
function module
   _module_raw $argv 2>&1
end}
         } else {
            append fdef end
         }
         if {[getConf ml]} {
            append fdef {
function ml
   module ml $argv
end}
         }
      }
      tcl {
         set fdef "proc module {args} {"
@quarantinesupport@         append fdef {
@quarantinesupport@   set _mlre {};
@quarantinesupport@   if {[info exists ::env(MODULES_RUN_QUARANTINE)]} {
@quarantinesupport@      foreach _mlv [split $::env(MODULES_RUN_QUARANTINE) " "] {
@quarantinesupport@         if {[regexp {^[A-Za-z_][A-Za-z0-9_]*$} $_mlv]} {
@quarantinesupport@            if {[info exists ::env($_mlv)]} {
@quarantinesupport@               lappend _mlre "__MODULES_QUAR_${_mlv}=$::env($_mlv)"
@quarantinesupport@            }
@quarantinesupport@            set _mlrv "MODULES_RUNENV_${_mlv}"
@quarantinesupport@            lappend _mlre [expr {[info exists ::env($_mlrv)] ?\
               "${_mlv}=$::env($_mlrv)" : "${_mlv}="}]
@quarantinesupport@         }
@quarantinesupport@      }
@quarantinesupport@      if {[llength $_mlre] > 0} {
@quarantinesupport@         set _mlre [linsert $_mlre 0 "env"]
@quarantinesupport@      }
@quarantinesupport@   }}
      append fdef {
   set _mlstatus 1;}
@quarantinesupport@         append fdef "\n   catch {exec {*}\$_mlre \"$tclshbin\"\
            \"$::argv0\" \"[getState shell]\" {*}\$args 2>@stderr} script\n"
@notquarantinesupport@         append fdef "\n   catch {exec \"$tclshbin\"\
            \"$::argv0\" \"[getState shell]\" {*}\$args 2>@stderr} script\n"
         append fdef {   eval $script;
   return $_mlstatus}
         append fdef "\n}"
         if {[getConf ml]} {
            append fdef {
proc ml {args} {
   return [module ml {*}$args]
}}
         }
      }
      cmd {
         reportErrorAndExit {No autoinit mode available for 'cmd' shell}
      }
      perl {
         set fdef "sub module {"
@quarantinesupport@         append fdef {
@quarantinesupport@   my $_mlre = '';
@quarantinesupport@   if (defined $ENV{'MODULES_RUN_QUARANTINE'}) {
@quarantinesupport@      foreach my $_mlv (split(' ', $ENV{'MODULES_RUN_QUARANTINE'})) {
@quarantinesupport@         if ($_mlv =~ /^[A-Za-z_][A-Za-z0-9_]*$/) {
@quarantinesupport@            if (defined $ENV{$_mlv}) {
@quarantinesupport@               $_mlre .= "__MODULES_QUAR_${_mlv}='$ENV{$_mlv}' ";
@quarantinesupport@            }
@quarantinesupport@            my $_mlrv = "MODULES_RUNENV_$_mlv";
@quarantinesupport@            $_mlre .= "$_mlv='$ENV{$_mlrv}' ";
@quarantinesupport@        }
@quarantinesupport@      }
@quarantinesupport@      if ($_mlre ne "") {
@quarantinesupport@         $_mlre = "env $_mlre";
@quarantinesupport@      }
@quarantinesupport@   }}
         append fdef {
   my $args = '';
   if (@_ > 0) {
      $args = '"' . join('" "', @_) . '"';
   }
   my $_mlstatus = 1;}
@quarantinesupport@         append fdef "\n   eval `\${_mlre}$tclshbin $::argv0 perl \$args`;\n"
@notquarantinesupport@         append fdef "\n   eval `$tclshbin $::argv0 perl \$args`;\n"
         append fdef {   return $_mlstatus;}
         append fdef "\n}"
         if {[getConf ml]} {
            append fdef {
sub ml {
   return module('ml', @_);
}}
         }
      }
      python {
         set fdef {import re, subprocess
def module(*arguments):}
@quarantinesupport@         append fdef {
@quarantinesupport@   _mlre = os.environ.copy()
@quarantinesupport@   if 'MODULES_RUN_QUARANTINE' in os.environ:
@quarantinesupport@      for _mlv in os.environ['MODULES_RUN_QUARANTINE'].split():
@quarantinesupport@         if re.match('^[A-Za-z_][A-Za-z0-9_]*$', _mlv):
@quarantinesupport@            if _mlv in os.environ:
@quarantinesupport@               _mlre['__MODULES_QUAR_' + _mlv] = os.environ[_mlv]
@quarantinesupport@            _mlrv = 'MODULES_RUNENV_' + _mlv
@quarantinesupport@            if _mlrv in os.environ:
@quarantinesupport@               _mlre[_mlv] = os.environ[_mlrv]
@quarantinesupport@            else:
@quarantinesupport@               _mlre[_mlv] = ''}
         append fdef {
   ns = {}}
@quarantinesupport@         append fdef "\n   exec(subprocess.Popen(\['$tclshbin',\
            '$::argv0', 'python'\] + list(arguments),\
            stdout=subprocess.PIPE, env=_mlre).communicate()\[0\], ns)\n"
@notquarantinesupport@         append fdef "\n   exec(subprocess.Popen(\['$tclshbin',\
            '$::argv0', 'python'\] + list(arguments),\
            stdout=subprocess.PIPE).communicate()\[0\], ns)\n"
         append fdef {   if '_mlstatus' in ns:
      _mlstatus = ns['_mlstatus']
   else:
      _mlstatus = True
   return _mlstatus}
         if {[getConf ml]} {
            append fdef {
def ml(*arguments):
   return module('ml', *arguments)
}
         }
      }
      ruby {
         set fdef {class ENVModule
   def ENVModule.module(*args)}
@quarantinesupport@         append fdef {
@quarantinesupport@      _mlre = ''
@quarantinesupport@      if ENV.has_key?('MODULES_RUN_QUARANTINE') then
@quarantinesupport@         ENV['MODULES_RUN_QUARANTINE'].split(' ').each do |_mlv|
@quarantinesupport@            if _mlv =~ /^[A-Za-z_][A-Za-z0-9_]*$/ then
@quarantinesupport@               if ENV.has_key?(_mlv) then
@quarantinesupport@                  _mlre << "__MODULES_QUAR_" + _mlv + "='" + ENV[_mlv].to_s + "' "
@quarantinesupport@               end
@quarantinesupport@               _mlrv = 'MODULES_RUNENV_' + _mlv
@quarantinesupport@               _mlre << _mlv + "='" + ENV[_mlrv].to_s + "' "
@quarantinesupport@            end
@quarantinesupport@         end
@quarantinesupport@         unless _mlre.empty?
@quarantinesupport@            _mlre = 'env ' + _mlre
@quarantinesupport@         end
@quarantinesupport@      end}
         append fdef {
      if args[0].kind_of?(Array) then
         args = args[0]
      end
      if args.length == 0 then
         args = ''
      else
         args = "\"#{args.join('" "')}\""
      end
      _mlstatus = true}
@quarantinesupport@         append fdef "\n      eval `#{_mlre}$tclshbin $::argv0 ruby #{args}`\n"
@notquarantinesupport@         append fdef "\n      eval `$tclshbin $::argv0 ruby #{args}`\n"
         append fdef {      return _mlstatus
   end}
         if {[getConf ml]} {
            append fdef {
   def ENVModule.ml(*args)
      return ENVModule.module('ml', *args)
   end}
         }
         append fdef {
end}
      }
      lisp {
         reportErrorAndExit {lisp mode autoinit not yet implemented}
      }
      cmake {
@quarantinesupport@         set pre_exec "\n      execute_process(COMMAND \${_mlre} $tclshbin\
            $::argv0 cmake "
@notquarantinesupport@         set pre_exec "\n      execute_process(COMMAND $tclshbin\
            $::argv0 cmake "
         set post_exec "\n         OUTPUT_FILE \${tempfile_name})\n"
         set fdef {function(module)
   cmake_policy(SET CMP0007 NEW)}
@quarantinesupport@         append fdef {
@quarantinesupport@   set(_mlre "")
@quarantinesupport@   if(DEFINED ENV{MODULES_RUN_QUARANTINE})
@quarantinesupport@      string(REPLACE " " ";" _mlv_list "$ENV{MODULES_RUN_QUARANTINE}")
@quarantinesupport@      foreach(_mlv ${_mlv_list})
@quarantinesupport@         if(${_mlv} MATCHES "^[A-Za-z_][A-Za-z0-9_]*$")
@quarantinesupport@            if(DEFINED ENV{${_mlv}})
@quarantinesupport@               set(_mlre "${_mlre}__MODULES_QUAR_${_mlv}=$ENV{${_mlv}};")
@quarantinesupport@            endif()
@quarantinesupport@            set(_mlrv "MODULES_RUNENV_${_mlv}")
@quarantinesupport@            set(_mlre "${_mlre}${_mlv}=$ENV{${_mlrv}};")
@quarantinesupport@        endif()
@quarantinesupport@      endforeach()
@quarantinesupport@      if (NOT "${_mlre}" STREQUAL "")
@quarantinesupport@         set(_mlre "env;${_mlre}")
@quarantinesupport@      endif()
@quarantinesupport@   endif()}
         append fdef {
   set(_mlstatus TRUE)
   execute_process(COMMAND mktemp -t moduleinit.cmake.XXXXXXXXXXXX
      OUTPUT_VARIABLE tempfile_name
      OUTPUT_STRIP_TRAILING_WHITESPACE)
   if(${ARGC} EQUAL 1)}
            # adapt command definition depending on the number of args to be
            # able to pass to some extend (<5 args) empty string element to
            # modulecmd (no other way as empty element in ${ARGV} are skipped
            append fdef "$pre_exec\"\${ARGV0}\"$post_exec"
            append fdef {   elseif(${ARGC} EQUAL 2)}
            append fdef "$pre_exec\"\${ARGV0}\" \"\${ARGV1}\"$post_exec"
            append fdef {   elseif(${ARGC} EQUAL 3)}
            append fdef "$pre_exec\"\${ARGV0}\" \"\${ARGV1}\"\
               \"\${ARGV2}\"$post_exec"
            append fdef {   elseif(${ARGC} EQUAL 4)}
            append fdef "$pre_exec\"\${ARGV0}\" \"\${ARGV1}\"\
               \"\${ARGV2}\" \"\${ARGV3}\"$post_exec"
            append fdef {   else()}
            append fdef "$pre_exec\${ARGV}$post_exec"
            append fdef {   endif()
   if(EXISTS ${tempfile_name})
      include(${tempfile_name})
      file(REMOVE ${tempfile_name})
   endif()
   set(module_result ${_mlstatus} PARENT_SCOPE)
endfunction(module)}
         if {[getConf ml]} {
            append fdef {
function(ml)
   module(ml ${ARGV})
   set(module_result ${module_result} PARENT_SCOPE)
endfunction(ml)}
         }
      }
      r {
         set fdef "module <- function(...){"
@quarantinesupport@         append fdef {
@quarantinesupport@   mlre <- ''
@quarantinesupport@   if (!is.na(Sys.getenv('MODULES_RUN_QUARANTINE', unset=NA))) {
@quarantinesupport@      for (mlv in strsplit(Sys.getenv('MODULES_RUN_QUARANTINE'), ' ')[[1]]) {
@quarantinesupport@         if (grepl('^[A-Za-z_][A-Za-z0-9_]*$', mlv)) {
@quarantinesupport@            if (!is.na(Sys.getenv(mlv, unset=NA))) {
@quarantinesupport@               mlre <- paste0(mlre, "__MODULES_QUAR_", mlv, "='", Sys.getenv(mlv), "' ")
@quarantinesupport@            }
@quarantinesupport@            mlrv <- paste0('MODULES_RUNENV_', mlv)
@quarantinesupport@            mlre <- paste0(mlre, mlv, "='", Sys.getenv(mlrv), "' ")
@quarantinesupport@         }
@quarantinesupport@      }
@quarantinesupport@      if (mlre != '') {
@quarantinesupport@         mlre <- paste0('env ', mlre)
@quarantinesupport@      }
@quarantinesupport@   }}
         append fdef {
   arglist <- as.list(match.call())
   arglist[1] <- 'r'
   args <- paste0('"', paste0(arglist, collapse='" "'), '"')}
@quarantinesupport@         append fdef "\n   cmd <- paste(mlre, '$tclshbin', '$::argv0', args,\
            sep=' ')\n"
@notquarantinesupport@         append fdef "\n   cmd <- paste('$tclshbin', '$::argv0', args,\
            sep=' ')\n"
         append fdef {   mlstatus <- TRUE
   hndl <- pipe(cmd)
   eval(expr = parse(file=hndl))
   close(hndl)
   invisible(mlstatus)}
         append fdef "\n}"
         if {[getConf ml]} {
            append fdef {
ml <- function(...){
   module('ml', ...)
}}
         }
      }
   }

   # output function definition
   puts stdout $fdef
}

proc get-env {var {valifunset {}}} {
   # return current value if exists and not cleared
   if {[info exists ::env($var)] && ![info exists ::g_clearedEnvVars($var)]} {
      return $::env($var)
   } else {
      return $valifunset
   }
}

proc set-env {var val} {
   set mode [currentState mode]
   reportDebug "$var=$val"

   # an empty string value means unsetting variable on Windows platform, so
   # call unset-env to ensure variable will not be seen defined yet raising
   # an error when trying to access it
   if {[getState is_win] && $val eq {}} {
      unset-env $var
   } else {
      interp-sync-env set $var $val

      # variable is not cleared anymore if set again
      if {[info exists ::g_clearedEnvVars($var)]} {
         unset ::g_clearedEnvVars($var)
      }

      # propagate variable setup to shell environment on load and unload mode
      if {$mode eq {load} || $mode eq {unload}} {
         set ::g_stateEnvVars($var) new
      }
   }
}

proc reset-to-unset-env {var {val {}}} {
   interp-sync-env set $var $val
   # set var as cleared if val is empty
   if {$val eq {}} {
      set ::g_clearedEnvVars($var) 1
   }
}

proc unset-env {var {internal 0} {val {}}} {
   set mode [currentState mode]
   reportDebug "$var (internal=$internal, val=$val)"

   # clear value instead of unset it not to break variable later reference
   # in modulefile. clear whether variable set or not to get a later usage
   # consistent behavior whatever env is setup
   if {!$internal} {
      reset-to-unset-env $var $val
   # internal variables (like ref counter var) are purely unset if they exists
   } elseif {[info exists ::env($var)]} {
      interp-sync-env unset $var
      set intwasset 1
   }

   # propagate deletion in any case if variable is public and for internal
   # one only if variable was set
   if {($mode eq {load} || $mode eq {unload}) && (!$internal ||\
      [info exists intwasset])} {
      set ::g_stateEnvVars($var) del
   }
}

proc getModshareVarName {var} {
   # specific modshare variable for DYLD-related variables as a suffixed
   # variable will lead to warning messages with this tool
   if {[string range $var 0 4] eq {DYLD_}} {
      return MODULES_MODSHARE_${var}
   } else {
      return ${var}_modshare
   }
}

# path fiddling
proc getReferenceCountArray {var separator} {
   # get reference counter set in environment
   set sharevar [getModshareVarName $var]
   array set refcount {}
   if {[info exists ::env($sharevar)]} {
      set modsharelist [psplit $::env($sharevar) [getState path_separator]]
      # ignore environment ref count variable if malformed
      if {([llength $modsharelist] % 2) == 0} {
         array set refcount $modsharelist
      } else {
         reportDebug "Reference counter value in '$sharevar' is malformed\
            ($modsharelist)"
      }
   }

   array set countarr {}
   if {[info exists ::env($var)]} {
      # do not skip a bare empty path entry that can also be found in
      # reference counter array (sometimes var is cleared by setting it
      # empty not unsetting it, ignore var in this case)
      if {$::env($var) eq {} && [info exists refcount()]} {
         lappend eltlist {}
      } else {
         set eltlist [split $::env($var) $separator]
      }

      # just go thought the elements of the variable, which means additional
      # elements part of the reference counter variable will be ignored
      foreach elt $eltlist {
         # no reference counter, means value has been set once
         if {![info exists refcount($elt)]} {
            set count 1
         # bad reference counter value is ignored
         } elseif {![string is digit -strict $refcount($elt)]} {
            reportDebug "Reference counter value for '$elt' in '$sharevar' is\
               erroneous ($refcount($elt))"
            set count 1
         } else {
            set count $refcount($elt)
         }
         set countarr($elt) $count
      }
   }

   set count_list [array get countarr]
   reportDebug "(var=$var, delim=$separator) got '$count_list'"

   return $count_list
}


proc unload-path {args} {
   reportDebug ($args)

   lassign [parsePathCommandArgs unload-path {*}$args] separator allow_dup\
      idx_val var path_list

   array set countarr [getReferenceCountArray $var $separator]

   # Don't worry about dealing with this variable if it is already scheduled
   #  for deletion
   if {[info exists ::g_stateEnvVars($var)] && $::g_stateEnvVars($var) eq\
      {del}} {
      return {}
   }

   # save initial variable content to match index arguments
   set dir_list [split [get-env $var] $separator]
   # detect if empty env value means empty path entry
   if {[llength $dir_list] == 0 && [info exists countarr()]} {
      lappend dir_list {}
   }

   # build list of index to remove from variable
   set del_idx_list [list]
   foreach dir $path_list {
      # retrieve dir value if working on an index list
      if {$idx_val} {
         set idx $dir
         # go to next index if this one is not part of the existing range
         # needed to distinguish an empty value to an out-of-bound value
         if {$idx < 0 || $idx >= [llength $dir_list]} {
            continue
         } else {
            set dir [lindex $dir_list $idx]
         }
      }

      # update reference counter array
      if {[info exists countarr($dir)]} {
         incr countarr($dir) -1
         set newcount $countarr($dir)
         if {$countarr($dir) <= 0} {
            unset countarr($dir)
         }
      } else {
         set newcount 0
      }

      # get all entry indexes corresponding to dir
      set found_idx_list [lsearch -all -exact $dir_list $dir]

      # remove all found entries
      if {$newcount <= 0} {
         # only remove passed position in --index mode
         if {$idx_val} {
            lappend del_idx_list $idx
         } else {
            lappend del_idx_list {*}$found_idx_list
         }
      # if multiple entries found remove the extra entries compared to new
      # reference counter
      } elseif {[llength $found_idx_list] > $newcount} {
         # only remove passed position in --index mode
         if {$idx_val} {
            lappend del_idx_list $idx
         } else {
            # delete extra entries, starting from end of the list (on a path
            # variable, entries at the end have less priority than those at
            # the start)
            lappend del_idx_list {*}[lrange $found_idx_list $newcount end]
         }
      }
   }

   # update variable if some element need to be removed
   if {[llength $del_idx_list] > 0} {
      set del_idx_list [lsort -integer -unique $del_idx_list]
      set newpath [list]
      set nbelem [llength $dir_list]
      # rebuild list of element without indexes set for deletion
      for {set i 0} {$i < $nbelem} {incr i} {
         if {$i ni $del_idx_list} {
            lappend newpath [lindex $dir_list $i]
         }
      }
   } else {
      set newpath $dir_list
   }

   # set env variable and corresponding reference counter in any case
   if {[llength $newpath] == 0} {
      unset-env $var
   } else {
      set-env $var [join $newpath $separator]
   }

   set sharevar [getModshareVarName $var]
   if {[array size countarr] > 0} {
      set-env $sharevar [pjoin [array get countarr] [getState path_separator]]
   } else {
      unset-env $sharevar 1
   }
   return {}
}

proc add-path {pos args} {
   reportDebug "($args) pos=$pos"

   lassign [parsePathCommandArgs add-path {*}$args] separator allow_dup\
      idx_val var path_list

   set sharevar [getModshareVarName $var]
   array set countarr [getReferenceCountArray $var $separator]

   if {$pos eq {prepend}} {
      set path_list [lreverse $path_list]
   }

   set val [get-env $var]

   foreach dir $path_list {
      if {![info exists countarr($dir)] || $allow_dup} {
         # ignore env var set empty if no empty entry found in reference
         # counter array (sometimes var is cleared by setting it empty not
         # unsetting it)
         if {$val ne {} || [info exists countarr()]} {
            set val [expr {$pos eq {prepend} ? "$dir$separator$val" :\
               "$val$separator$dir"}]
         } else {
            set val $dir
         }
      }
      if {[info exists countarr($dir)]} {
         incr countarr($dir)
      } else {
         set countarr($dir) 1
      }
   }

   set-env $var $val
   set-env $sharevar [pjoin [array get countarr] [getState path_separator]]

   return {}
}

# analyze argument list passed to a path command to set default value or raise
# error in case some attributes are missing
proc parsePathCommandArgs {cmd args} {
   # parse argument list
   set next_is_delim 0
   set allow_dup 0
   set idx_val 0
   foreach arg $args {
      # everything passed after variable name is considered a value
      if {[info exists var]} {
         # set multiple passed values in a list
         lappend val_raw_list $arg
      } else {
         switch -glob -- $arg {
            --index {
               if {$cmd eq {add-path}} {
                  reportWarning "--index option has no effect on $cmd"
               } else {
                  set idx_val 1
               }
            }
            --duplicates {
               if {$cmd eq {unload-path}} {
                  reportWarning "--duplicates option has no effect on $cmd"
               } else {
                  set allow_dup 1
               }
            }
            -d - -delim - --delim {
               set next_is_delim 1
            }
            --delim=* {
               set delim [string range $arg 8 end]
            }
            -* {
               knerror "invalid option '$arg' for $cmd"
            }
            default {
               if {$next_is_delim} {
                  set delim $arg
                  set next_is_delim 0
               } else {
                  set var $arg
               }
            }
         }
      }
   }

   # adapt with default value or raise error if some arguments are missing
   if {![info exists delim]} {
      set delim [getState path_separator]
   } elseif {$delim eq {}} {
      knerror "$cmd should get a non-empty path delimiter"
   }
   if {![info exists var]} {
      knerror "$cmd should get an environment variable name"
   } elseif {$var eq {}} {
      knerror "$cmd should get a valid environment variable name"
   }
   if {![info exists val_raw_list]} {
      knerror "$cmd should get a value for environment variable $var"
   }

   # set list of value to add
   set val_list [list]
   foreach val $val_raw_list {
      # check passed indexes are numbers
      if {$idx_val && ![string is integer -strict $val]} {
         knerror "$cmd should get valid number as index value"
      }

      switch -- $val \
         {} {
            # add empty entry in list
            lappend val_list {}
         } \
         $delim {
            knerror "$cmd cannot handle path equals to separator string"
         } \
         default {
            # split passed value with delimiter
            lappend val_list {*}[split $val $delim]
         }
   }

   reportDebug "(delim=$delim, allow_dup=$allow_dup, idx_val=$idx_val,\
      var=$var, val=$val_list, nbval=[llength $val_list])"

   return [list $delim $allow_dup $idx_val $var $val_list]
}


##############################################################################
# Report ---------------------------------------------------------------------
##############################################################################

#
# Debug, Info, Warnings and Error message handling.
#

# save message when report is not currently initialized as we do not
# know yet if debug mode is enabled or not
proc reportDebug {message {showcaller 1} {caller _undef_}} {
   # get caller name
   if {$caller eq {_undef_} && $showcaller} {
      if {[info level] > 1} {
         set caller [lindex [info level -1] 0]
      } else {
         set caller {}
      }
   }
   lappend ::errreport_buffer [list reportDebug $message $showcaller $caller]
}

# regular procedure to use once error report is initialized
proc __reportDebug {message {showcaller 1} {caller _undef_}} {
   # display active interp details if not the main one
   set prefix [currentState debug_msg_prefix]
   # display caller name as prefix
   if {$showcaller && $caller ne {} && ($caller ne {_undef_} || [info level]\
      > 1)} {
      if {$caller eq {_undef_}} {
         set caller [lindex [info level -1] 0]
      }
      append prefix "$caller: "
   }
   report [sgr db "DEBUG $prefix$message"] 0 1
}

# alternative procedure used when debug is disabled
proc __reportDebugNop {args} {}

proc reportWarning {message {recordtop 0}} {
   reportError $message $recordtop WARNING wa 0
}

proc reportError {message {recordtop 0} {severity ERROR} {sgrkey er}\
   {raisecnt 1}} {
   lappend ::errreport_buffer [list reportError $message $recordtop $severity\
      $sgrkey $raisecnt]
}

proc __reportError {message {recordtop 0} {severity ERROR} {sgrkey er}\
   {raisecnt 1}} {
   # if report disabled, also disable error raise to get a coherent
   # behavior (if no message printed, no error code change)
   if {![getState inhibit_errreport]} {
      if {$raisecnt} {
         raiseErrorCount
      }
      set msgsgr "[sgr $sgrkey $severity]: $message"
      # record message to report it later on if a record id is found
      if {[currentState msgrecordid] ne {}} {
         recordMessage $msgsgr $recordtop
      # skip message report if silent
      } elseif {[isVerbosityLevel concise]} {
         # save error messages to render them all together in JSON format
         if {[isStateEqual report_format json]} {
            lappend ::g_report_erralist $severity $message
         } else {
            report $msgsgr 0 0 1
         }
      }
   }
}

# throw known error (call error with 'known error' code)
proc knerror {message {code MODULES_ERR_KNOWN}} {
   error $message {} $code
}

# save message if report is not yet initialized
proc reportErrorAndExit {message} {
   lappend ::errreport_buffer [list reportErrorAndExit $message]
}

# regular procedure to use once error report is initialized
proc __reportErrorAndExit {message} {
   raiseErrorCount
   renderFalse
   error $message {} MODULES_ERR_RENDERED
}

proc reportInternalBug {message {modfile {}}} {
   if {$modfile ne {}} {
      append message "\nIn '$modfile'"
   }
   append message "\nPlease contact <[getConf contact]>"
   reportError $message 0 {Module ERROR} me
}

proc reportInfo {message {title INFO}} {
   if {[isVerbosityLevel normal]} {
      # use reportError for convenience but there is no error here
      reportError $message 0 $title in 0
   }
}

proc reportTrace {message {title TRACE}} {
   if {[isVerbosityLevel trace]} {
      # use reportError for convenience but there is no error here
      reportError [sgr tr $message] 0 $title tr 0
   }
}

# trace procedure execution start
proc reportTraceExecEnter {cmdstring op} {
   set caller [expr {[info level] > 1 ? [lindex [info level -1] 0] : {}}]
   reportDebug $cmdstring 1 $caller
}

# is currently active message record id at top level
proc isMsgRecordIdTop {} {
   return [expr {[depthState msgrecordid] eq 1}]
}

# record messages on the eventual additional module evaluations that have
# occurred during the current evaluation
proc reportModuleEval {} {
   set evalid [currentState evalid]
   array set contexttitle {conun {Unloading conflict} reqlo {Loading\
      requirement} depre {Reloading dependent} depun {Unloading dependent}\
      urequn {Unloading useless requirement}}

   if {[info exists ::g_moduleEval($evalid)]} {
      foreach contextevallist $::g_moduleEval($evalid) {
         set msgrecidlist [lassign $contextevallist context]
         # skip context with no description title
         if {[info exists contexttitle($context)]} {
            # exclude hidden modules from report unless an high level of
            # verbosity is set
            if {[info exists ::g_moduleHiddenEval($evalid:$context)] &&\
               ![isVerbosityLevel verbose2]} {
               lassign [getDiffBetweenList $msgrecidlist\
                  $::g_moduleHiddenEval($evalid:$context)] msgrecidlist
            }

            if {[llength $msgrecidlist] > 0} {
               set moddesiglist {}
               foreach msgrecid $msgrecidlist {
                  lappend moddesiglist [getModuleDesignation $msgrecid]
               }
               reportInfo [join $moddesiglist] $contexttitle($context)
            }
         }
      }
      # purge list in case same evaluation is re-done afterward
      unset ::g_moduleEval($evalid)
   }
}

# render messages related to current record id under an header block
proc reportMsgRecord {header {hidden 0}} {
   set recid [currentState msgrecordid]
   if {[info exists ::g_msgRecord($recid)]} {
      # skip message report if silent (report even if hidden as soon as msgs
      # are associated to hidden module evaluation)
      if {[isVerbosityLevel concise]} {
         set tty_cols [getState term_columns]
         set padding {  }

         set dispmsg $header
         foreach msg $::g_msgRecord($recid) {
            # split lines if too large for terminal
            set first 1
            set max_idx [tcl::mathfunc::max [expr {$tty_cols - [string length\
               $padding]}] 1]
            set linelist [list]
            foreach line [split $msg \n] {
               set lineadd {}
               while {$lineadd ne $line} {
                  set line_max_idx $max_idx
                  # sgr tags consume no length
                  set eidx 0
                  while {[set sidx [string first "\033\[" $line $eidx]] !=\
                     -1} {
                     set eidx [string first m $line $sidx]
                     incr line_max_idx [expr {1 + $eidx - $sidx}]
                  }

                  # no split if no whitespace found to slice
                  if {[string length $line] > $line_max_idx && [set cut_idx\
                     [string last { } $line $line_max_idx]] != -1} {
                     set lineadd [string range $line 0 [expr {$cut_idx-1}]]
                     set line [string range $line [expr {$cut_idx+1}] end]
                  } else {
                     set lineadd $line
                  }
                  # skip empty line
                  if {[string trim $lineadd] ne {}} {
                     lappend linelist $lineadd
                  }
                  if {$first} {
                     set first 0
                     incr max_idx -[string length $padding]
                     if {$max_idx < 1} {set max_idx 1}
                  }
               }
            }

            # display each line
            set first 1
            foreach line $linelist {
               append dispmsg \n
               if {$first} {
                  set first 0
               } else {
                  append dispmsg $padding
               }
               append dispmsg $padding$line
            }
         }
         reportSeparateNextContent
         report $dispmsg
         reportSeparateNextContent
      }

      # purge message list in case same evaluation is re-done afterward
      unset ::g_msgRecord($recid)
   # report header if no other specific msg to output in verbose mode or in
   # normal verbosity mode if currently processing a cmd which triggers
   # multiple module evaluations that cannot be guessed by the user
   # if hidden flag is enabled report only if verbosity >= verbose2
   } elseif {(!$hidden && ([isVerbosityLevel verbose] || ([isVerbosityLevel\
      normal] && ([ongoingCommandName restore] || [ongoingCommandName\
      source])))) || ($hidden && [isVerbosityLevel verbose2])} {
      report $header
   }
}

# separate next content produced if any
proc reportSeparateNextContent {} {
   lappend ::errreport_buffer [list reportSeparateNextContent]
}

# regular procedure to use once error report is initialized
proc __reportSeparateNextContent {} {
   # hold or apply
   if {[depthState reportholdid] > 0} {
      lappend ::g_holdReport([currentState reportholdid]) [list\
         reportSeparateNextContent]
   } else {
      setState report_sep_next 1
   }
}

# save message for block rendering
proc recordMessage {message {recordtop 0}} {
   lappend ::g_msgRecord([expr {$recordtop ? [topState msgrecordid] :\
      [currentState msgrecordid]}]) $message
}

# check if some msg have been recorded for current evaluation
proc isMsgRecorded {} {
   return [info exists ::g_msgRecord([currentState msgrecordid])]
}

# filter and format error stack trace to only report useful content
proc formatErrStackTrace {errmsg loc {cmdlist {}}} {
   set headstr "\n    while executing\n"
   set splitstr "\n    invoked from within\n"
   set splitstrlen [string length $splitstr]
   set aftheadidx [string first $headstr $errmsg]
   if {$aftheadidx != -1} {
      incr aftheadidx [string length $headstr]
   }

   # get name of invalid command name to maintain it in error stack trace
   if {[string equal -length 22 {invalid command name "} $errmsg]} {
      set unkcmd [lindex [split [string range $errmsg 0 $aftheadidx] {"}] 1]
   } else {
      set unkcmd {}
   }

   # get list of modulecmd.tcl internal procedure to filter out from stack
   # skip this when no interp command list is provided
   if {[llength $cmdlist] > 0} {
      lassign [getDiffBetweenList [list {*}[info commands] {*}[info procs]]\
         $cmdlist] filtercmdlist keepcmdlist
   } else {
      set filtercmdlist {}
   }

   # define commands to filter out from bottom of stack
   set filtercmdendlist [list {eval $modcontent} "source $loc" {uplevel 1\
      source $siteconfig}]

   # filter out modulecmd internal references at beginning of stack
   set internals 1
   while {$internals && $aftheadidx != -1} {
      # fetch erroneous command and its caller
      set stackelt [string range $errmsg $aftheadidx [string first\
         $splitstr $errmsg $aftheadidx]]
      lassign [split [lindex [split $stackelt {"}] 1]] cmd1 cmd2
      set cmdcaller [lindex [split [string range $stackelt [string last\
         {(procedure } $stackelt] end] {"}] 1]
      if {$cmd1 eq {eval}} {
         set cmd1 $cmd2
      }

      # filter out stack element referring to or called by an unknown procedure
      # (ie. a modulecmd.tcl internal procedure)
      if {[string index $cmd1 0] ne {$} && $cmd1 ne $unkcmd && ($cmdcaller in\
         $filtercmdlist || $cmd1 in $filtercmdlist)} {
         set errmsg [string replace $errmsg $aftheadidx [expr {[string first\
            $splitstr $errmsg] + $splitstrlen - 1}]]
      } else {
         set internals 0
      }
   }

   # filter out modulecmd internal references at end of stack
   set internals 1
   while {$internals} {
      set beffootidx [string last $splitstr $errmsg]
      set stackelt [string range $errmsg $beffootidx end]
      set cmd [lindex [split $stackelt {"}] 1]

      if {$cmd in $filtercmdendlist} {
         set errmsg [string replace $errmsg $beffootidx end]
      } else {
         set internals 0
      }
   }

   # replace error location at end of stack
   set lastnl [string last \n $errmsg]
   set lastline [string range $errmsg [expr {$lastnl + 1}] end]
   if {[string match {    ("eval" body line*} $lastline]} {
      set errmsg [string replace $errmsg $lastnl [expr {$lastnl + [string\
         length "    (\"eval\" body line"]}] "\n    (file \"$loc\" line"]
   } elseif {![string match {    (file *} $lastline]} {
      # add error location at end of stack
      append errmsg "\n    (file \"$loc\")"
   }

   return $errmsg
}

# Test if color is enabled and passed sgrkey is defined and not null
proc isSgrkeyColored {sgrkey} {
   return [expr {[getConf color] && [info exists ::g_colors($sgrkey)] &&\
      $::g_colors($sgrkey) ne {}}]
}

# Select Graphic Rendition of a string with passed sgr keys (if color enabled)
proc sgr {keylist str {himatchmap {}} {othkeylist {}}} {
   if {[getConf color]} {
      set sgrreset 22
      foreach sgrkey $keylist {
         if {[info exists ::g_colors($sgrkey)]} {
            # track color key that have been used
            if {![info exists ::g_used_colors($sgrkey)]} {
               set ::g_used_colors($sgrkey) 1
            }
            if {[info exists sgrset]} {
               append sgrset {;}
            }
            append sgrset $::g_colors($sgrkey)
            # if render bold or faint just reset that attribute, not all
            if {$sgrreset != 0 && $sgrset != 1 && $sgrset != 2} {
               set sgrreset 0
            }
         }
      }
      if {[llength $othkeylist] == 0} {
         # highlight matching substring
         if {[llength $himatchmap] > 0} {
            set str [string map $himatchmap $str]
         }
         if {[info exists sgrset]} {
            set str "\033\[${sgrset}m$str\033\[${sgrreset}m"
         }
      } else {
         if {![info exists sgrset]} {
            set sgrset {}
         } else {
            append sgrset {;}
         }
         # determine each chunk where the other sgr keys apply
         set tagsgrlen [expr {int(ceil([string length $str]/[llength\
            $othkeylist]))}]
         for {set i 0} {$i < [llength $othkeylist]} {incr i} {
            set idx [expr {$i*$tagsgrlen}]
            set sgrkey [lindex $othkeylist $i]
            lappend sgridxlist $idx $::g_colors($sgrkey)
            # track color key that have been used
            if {![info exists ::g_used_colors($sgrkey)]} {
               set ::g_used_colors($sgrkey) 1
            }
         }
         # determine each chunk where the highlight applies
         set hiidxlist {}
         foreach {mstr sgrmstr} $himatchmap {
            set idx 0
            while {$idx != -1} {
               if {[set idx [string first $mstr $str $idx]] != -1} {
                  lappend hiidxlist $idx
                  incr idx [string length $mstr]
                  # add highlight end index unless if end of string
                  if {$idx < [string length $str]} {
                     lappend hiidxlist $idx
                  }
               }
            }
            # no need to look at next match string if this one was found
            if {[llength $hiidxlist] > 0} {
               break
            }
         }

         # mix other sgr chunks with highlighted chunks to define sgr codes
         set i 0
         set j 0
         set sgridx [lindex $sgridxlist 0]
         set hiidx [lindex $hiidxlist 0]
         set hicur 0
         set sgrcur {}
         set sgrrst {0;}
         while {$i < [llength $sgridxlist] || $j < [llength $hiidxlist]} {
            set sgrcode {}
            set cursgridx $sgridx
            # sgr chunk change
            if {$sgridx ne {} && ($hiidx eq {} || $sgridx <= $hiidx)} {
               incr i
               set sgrcur $sgrset[lindex $sgridxlist $i]
               set idx $sgridx
               if {$idx != 0} {
                  append sgrcode $sgrrst
               }
               append sgrcode $sgrcur
               incr i
               set sgridx [lindex $sgridxlist $i]
            }
            # highlight change
            if {$hiidx ne {} && ($cursgridx eq {} || $hiidx <= $cursgridx)} {
               set idx $hiidx
               set hicur [expr {!$hicur}]
               if {$hicur} {
                  if {$sgrcode ne {}} {
                     append sgrcode {;}
                  }
                  append sgrcode $::g_colors(hi)
               # restore current sgr set to only clear highlight
               } elseif {$sgrcode eq {}} {
                  append sgrcode $sgrrst $sgrcur
               }
               incr j
               set hiidx [lindex $hiidxlist $j]
            } elseif {$hicur} {
               append sgrcode {;} $::g_colors(hi)
            }
            lappend fullsgridxlist $idx $sgrcode
         }
         # reset sgr at end of string
         lappend fullsgridxlist [string length $str] 0

         # apply defined sgr codes to the string
         set stridx 0
         foreach {sgridx sgrcode} $fullsgridxlist {
            if {$sgridx != 0} {
               append sgrstr [string range $str $stridx [expr {$sgridx-1}]]
            }
            append sgrstr "\033\[${sgrcode}m"
            set stridx $sgridx
         }
         set str $sgrstr
      }
   }
   return $str
}

# Sort tags to return those matching defined sgr keys in a list up to a given
# maxnb number and if tag not set to be displayed by its name. Other elements
# are returned in a separate list
proc getTagSgrForModname {keylist maxnb} {
   set sgrkeylist {}
   if {[getConf color]} {
      set otherlist {}
      foreach key $keylist {
         if {[info exists ::g_colors($key)] && ![info exists\
            ::g_tagColorName($key)] && [llength $sgrkeylist] < $maxnb} {
            lappend sgrkeylist $key
         } else {
            lappend otherlist $key
         }
      }
   } else {
      set otherlist $keylist
   }
   return [list $sgrkeylist $otherlist]
}

# save message if report is not yet initialized
proc report {message {nonewline 0} {immed 0} {padnl 0}} {
   lappend ::errreport_buffer [list report $message $nonewline $immed $padnl]
}

# regular procedure to use once error report is initialized
proc __report {message {nonewline 0} {immed 0} {padnl 0}} {
   # hold or print output
   if {!$immed && [depthState reportholdid] > 0} {
      lappend ::g_holdReport([currentState reportholdid]) [list report\
         $message $nonewline $immed $padnl]
   } else {
      # produce blank line prior message if asked to
      if {[isStateDefined reportfd] && [isStateDefined report_sep_next]} {
         unsetState report_sep_next
         report [expr {[isStateEqual report_format json] ? {,} : {}}]
      }
      # prefix msg lines after first one with 2 spaces
      if {$padnl} {
         set first 1
         foreach line [split $message \n] {
            if {$first} {
               set first 0
            } else {
               append padmsg "\n  "
            }
            append padmsg $line
         }
         set message $padmsg
      }

      # protect from issue with fd, just ignore it
      catch {
         if {$nonewline} {
            puts -nonewline [getState reportfd] $message
         } else {
            puts [getState reportfd] $message
         }
      }
   }
}

# report error the correct way depending of its type
proc reportIssue {issuetype issuemsg {issuefile {}}} {
   switch -- $issuetype {
      invalid {
         reportInternalBug $issuemsg $issuefile
      }
      default {
         reportError $issuemsg
      }
   }
}

# report defined command (used in display evaluation mode)
proc reportCmd {cmd args} {
   # use Tcl native string representation of list
   if {$cmd eq {-nativeargrep}} {
      set cmd [lindex $args 0]
      set cmdargs [lrange $args 1 end]
   } else {
      set cmdargs [listTo tcl $args 0]
   }
   set extratab [expr {[string length $cmd] < 8 ? "\t" : {}}]
   report [sgr cm $cmd]$extratab\t$cmdargs

   # empty string returns if command result is another command input
   return {}
}

# report defined command (called as an execution trace)
proc reportCmdTrace {cmdstring args} {
   reportCmd {*}$cmdstring
}

proc reportVersion {} {
   report {Modules Release @MODULES_RELEASE@@MODULES_BUILD@\
      (@MODULES_BUILD_DATE@)}
}

# disable error reporting (non-critical report only) unless debug enabled
proc inhibitErrorReport {} {
   if {![isVerbosityLevel trace]} {
      setState inhibit_errreport 1
   }
}

# init error report and output buffered messages
proc initErrorReport {} {
   # ensure init is done only once
   if {![isStateDefined init_error_report]} {
      setState init_error_report 1

      # ask for color init now as debug mode has already fire lines to render
      # and we want them to be reported first (not the color init lines)
      if {[isVerbosityLevel debug]} {
         getConf color
      }

      # trigger pager start if something needs to be printed, to guaranty
      # reportDebug calls during pager start are processed in buffer mode
      if {[isVerbosityLevel debug]} {
         getState reportfd
      }

      # replace report procedures used to buffer messages until error report
      # being initialized by regular report procedures
      rename ::reportDebug {}
      if {[isVerbosityLevel debug]} {
         rename ::__reportDebug ::reportDebug
      } else {
         # set a disabled version if debug is disabled
         rename ::__reportDebugNop ::reportDebug
      }
      rename ::reportError {}
      rename ::__reportError ::reportError
      rename ::reportErrorAndExit {}
      rename ::__reportErrorAndExit ::reportErrorAndExit
      rename ::reportSeparateNextContent {}
      rename ::__reportSeparateNextContent ::reportSeparateNextContent
      rename ::report {}
      rename ::__report ::report

      # trace each procedure call
      if {[isVerbosityLevel debug2]} {
         # exclude core procedure from tracing
         set excl_prc_list [list report reportDebug reportTraceExecEnter\
            getState setState unsetState lappendState lpopState currentState\
            depthState isStateDefined isStateEqual sgr getConf setConf\
            unsetConf lappendConf]
         foreach prc [info procs] {
            if {$prc ni $excl_prc_list} {
               trace add execution $prc enter reportTraceExecEnter
            }
         }
      }

      # now error report is init output every message saved in buffer; first
      # message will trigger message paging configuration and startup unless
      # already done if debug mode enabled
      foreach errreport $::errreport_buffer {
         {*}$errreport
      }
   }
}

# drop or report held messages
proc releaseHeldReport {args} {
   foreach {holdid action} $args {
      if {[info exists ::g_holdReport($holdid)]} {
         if {$action eq {report}} {
            foreach repcall $::g_holdReport($holdid) {
               {*}$repcall
            }
         }
         unset ::g_holdReport($holdid)
      }
   }
}

# check if element passed as argument (corresponding to a kind of information)
# should be part of output content
proc isEltInReport {elt {retifnotdef 1}} {
   # get config name relative to current sub-command and output format
   set conf [currentState commandname]
   if {[getState report_format] ne {regular}} {
      append conf _[getState report_format]
   }
   append conf _output
   set arrname ::g_$conf

   if {[info exists ::g_config_defs($conf)]} {
      # build value cache if it does not exist yet
      if {![array exists $arrname]} {
         array set $arrname {}
         foreach confelt [split [getConf $conf] :] {
            set ${arrname}($confelt) 1
         }
      }

      # check if elt is marked to be included in output
      set ret [info exists ${arrname}($elt)]
   } else {
      # return $retifnotdef (ok by default) in case no config option
      # corresponds to the current module sub-command and output format
      set ret $retifnotdef
   }

   return $ret
}

proc registerModuleDesignation {evalid mod vrlist} {
   set ::g_moduleDesgination($evalid) [list $mod $vrlist]
}

proc getModuleDesignation {from {mod {}} {sgr 1}} {
   # fetch module name version and variants from specified context
   switch -- $from {
      spec {
         set moddesig [getModuleNameAndVersFromVersSpec $mod]
         set vrlist [getVariantList $mod 1 0 1]
      }
      loaded {
         set moddesig $mod
         set vrlist [getVariantList $mod 1]
      }
      default {
         # fetch information from passed evaluation id
         if {[info exists ::g_moduleDesgination($from)]} {
            lassign $::g_moduleDesgination($from) moddesig vrlist
         # if not found, use passed spec to compute designation
         } else {
            set moddesig [getModuleNameAndVersFromVersSpec $mod]
            set vrlist [getVariantList $mod 1 0 1]
         }
      }
   }

   # build module designation
   # add module name and version to the designation
   if {$sgr > 1} {
      set desig [sgr hi $moddesig]
   } else {
      set desig $moddesig
   }
   # enclose module name between quotes if a space is found
   if {[string first { } $moddesig] != -1} {
      set desig '$desig'
   }

   # add variant specification to the designation
   if {[llength $vrlist] > 0} {
      foreach vr $vrlist {
         switch -- $sgr {
            2 {set vrdesig [sgr va $vr]}
            1 {set vrdesig [sgr {se va} $vr]}
            0 {set vrdesig $vr}
         }
         lappend vrdesiglist $vrdesig
      }
      if {$sgr > 0} {
         append desig [sgr se "\{"] [join $vrdesiglist [sgr se :]] [sgr se\
            "\}"]
      } else {
         append desig "\{" [join $vrdesiglist :] "\}"
      }
   }

   return $desig
}

#
# Helper procedures to format various messages
#

proc getHintUnFirstMsg {modlist} {
   return "HINT: Might try \"module unload [join $modlist]\" first."
}

proc getHintLoFirstMsg {modlist} {
   if {[llength $modlist] > 1} {
      set oneof {at least one of }
      set mod modules
   } else {
      set oneof {}
      set mod module
   }
   return "HINT: ${oneof}the following $mod must be loaded first: [join\
      $modlist]"
}

proc getErrConflictMsg {conlist} {
   return "Module cannot be loaded due to a conflict.\n[getHintUnFirstMsg\
      $conlist]"
}

proc getErrPrereqMsg {prelist {load 1}} {
   if {$load} {
      foreach pre $prelist {
         lappend predesiglist [getModuleDesignation spec $pre]
      }
      lassign [list {} missing [getHintLoFirstMsg $predesiglist]] un mis\
         hintmsg
   } else {
      lassign [list un a [getHintUnFirstMsg $prelist]] un mis hintmsg
   }
   return "Module cannot be ${un}loaded due to $mis prereq.\n$hintmsg"
}

proc getErrReqLoMsg {prelist} {
   foreach pre $prelist {
      lappend predesiglist [getModuleDesignation spec $pre]
   }
   return "Load of requirement [join $predesiglist { or }] failed"
}

proc getReqNotLoadedMsg {prelist} {
   foreach pre $prelist {
      lappend predesiglist [getModuleDesignation spec $pre]
   }
   return "Requirement [join $predesiglist { or }] is not loaded"
}

proc getDepLoadedMsg {prelist} {
   set is [expr {[llength $prelist] > 1 ? {are} : {is}}]
   foreach pre $prelist {
      lappend predesiglist [getModuleDesignation loaded $pre]
   }
   return "Dependent [join $predesiglist { and }] $is loaded"
}

proc getErrConUnMsg {conlist} {
   set condesiglist {}
   foreach con $conlist {
      lappend condesiglist [getModuleDesignation spec $con]
   }
   return "Unload of conflicting [join $condesiglist { and }] failed"
}

proc getConIsLoadedMsg {conlist {loading 0}} {
   set is [expr {[llength $conlist] > 1 ? {are} : {is}}]
   set loaded [expr {$loading ? {loading} : {loaded}}]
   set condesiglist {}
   foreach con $conlist {
      lappend condesiglist [getModuleDesignation spec $con]
   }
   return "Conflicting [join $condesiglist { and }] $is $loaded"
}

proc getForbiddenMsg {mod} {
   set msg "Access to module [getModuleDesignation spec $mod 2] is denied"
   set extramsg [getModuleTagProp $mod forbidden message]
   if {$extramsg ne {}} {
      append msg \n$extramsg
   }
   return $msg
}

proc getNearlyForbiddenMsg {mod} {
   set after [getModuleTagProp $mod nearly-forbidden after]
   set msg "Access to module will be denied starting '$after'"
   set extramsg [getModuleTagProp $mod nearly-forbidden message]
   if {$extramsg ne {}} {
      append msg \n$extramsg
   }
   return $msg
}

proc getStickyUnloadMsg {{tag sticky}} {
   return "Unload of $tag module skipped"
}

proc getStickyForcedUnloadMsg {} {
   return {Unload of sticky module forced}
}

proc getModWithAltVrIsLoadedMsg {mod} {
   set vrdesiglist {}
   foreach vr [getVariantList $mod 1] {
      lappend vrdesiglist [sgr va $vr]
   }
   return "Variant [sgr se "\{"][join $vrdesiglist [sgr se :]][sgr se "\}"]\
      is already loaded"
}

proc getEmptyNameMsg {type} {
   return "Invalid empty $type name"
}

#
# Stack of message recording/eval unique identifiers
#

proc pushMsgRecordId {recid {setmsgid 1}} {
   lappendState evalid $recid
   if {$setmsgid} {
      lappendState msgrecordid $recid
   }
}

proc popMsgRecordId {{setmsgid 1}} {
   lpopState evalid
   if {$setmsgid} {
      lpopState msgrecordid
   }
}

proc clearAllMsgRecordId {} {
   if {[isStateDefined evalid]} {
      unsetState evalid
   }
   if {[isStateDefined msgrecordid]} {
      unsetState msgrecordid
   }
}

#
# Format output text
#

# format an element with its syms for display in a list
proc formatListEltToDisplay {elt eltsgr eltsuffix sym_list symsgr show_syms\
   sgrdef tag_list show_tags vr_list vrsgr show_vrs {himatchmap {}}} {
   # fetch sgr codes from tags to apply directly on main element
   if {$show_tags && [llength $tag_list] > 0} {
      # if more codes than character in elt, additional codes apply to the
      # side tag list
      lassign [getTagSgrForModname $tag_list [string length $elt]] tagsgrlist\
         tag_list
   } else {
      set tagsgrlist {}
   }
   # display default sym graphically over element name
   if {$show_syms} {
      if {[set defidx [lsearch -exact $sym_list default]] != -1 && $sgrdef} {
         set sym_list [lreplace $sym_list $defidx $defidx]
         lappend eltsgrlist de
      }
   }

   set disp $elt$eltsuffix
   lappend eltsgrlist $eltsgr
   set dispsgr [sgr $eltsgrlist $elt $himatchmap $tagsgrlist]$eltsuffix

   # format variant list if any
   if {$show_vrs && [llength $vr_list] > 0} {
      append disp "{[join $vr_list :]}"
      set vrssgr "[sgr se \{]"
      foreach vr $vr_list {
         if {[info exists notfirstvr]} {
            set colonsgr [sgr se :]
            append vrssgr $colonsgr
         } else {
            set notfirstvr 1
         }
         append vrssgr [sgr $vrsgr $vr]
      }
      append vrssgr [sgr se \}]
      append dispsgr $vrssgr
   }

   # format remaining sym list
   if {$show_syms && [llength $sym_list] > 0} {
      # track if a symbol has been reported excluding sym for alias '@'
      if {![info exists ::g_used_sym_nocolor] && ([llength $sym_list] > 1 ||
         [lindex $sym_list 0] ne {@})} {
         set ::g_used_sym_nocolor 1
      }
      append disp "([join $sym_list :])"
      set symssgr [sgr se (]
      foreach sym $sym_list {
         if {[info exists notfirstsym]} {
            if {![info exists colonsgr]} {
               set colonsgr [sgr se :]
            }
            append symssgr $colonsgr
         } else {
            set notfirstsym 1
         }
         append symssgr [sgr $symsgr $sym]
      }
      append symssgr [sgr se )]
      append dispsgr $symssgr
   }

   # format tag list if any remaining
   if {$show_tags && [llength $tag_list] > 0} {
      append disp " <[join $tag_list :]>"
      set tagssgr " [sgr se <]"
      foreach tag $tag_list {
         # track tag name or abbreviation that have been used
         if {![info exists ::g_used_tags($tag)]} {
            set ::g_used_tags($tag) 1
         }
         if {[info exists notfirsttag]} {
            if {![info exists colonsgr]} {
               set colonsgr [sgr se :]
            }
            append tagssgr $colonsgr
         } else {
            set notfirsttag 1
         }
         # try to sgr in case a code apply to the tag
         append tagssgr [sgr $tag $tag]
      }
      append tagssgr [sgr se >]
      append dispsgr $tagssgr
   }

   return [list $disp $dispsgr]
}

# format an element with its syms for a long/detailed display in a list
proc formatListEltToLongDisplay {elt eltsgr eltsuffix sym_list symsgr mtime\
   sgrdef {himatchmap {}}} {
   set disp $elt$eltsuffix
   set displen [string length $disp]
   # display default sym graphically over element name
   if {[set defidx [lsearch -exact $sym_list default]] != -1 && $sgrdef} {
      set sym_list [lreplace $sym_list $defidx $defidx]
      lappend eltsgrlist de
   }
   lappend eltsgrlist $eltsgr
   set dispsgr [sgr $eltsgrlist $elt $himatchmap]$eltsuffix
   # format remaining sym list
   if {[llength $sym_list] > 0} {
      set symslen [string length [join $sym_list :]]
      foreach sym $sym_list {
         if {![info exists colonsgr]} {
            set colonsgr [sgr se :]
         } else {
            append symssgr $colonsgr
         }
         append symssgr [sgr $symsgr $sym]
      }
   } else {
      set symssgr {}
      set symslen 0
   }
   set nbws1 [expr {40 - $displen}]
   set nbws2 [expr {20 - $symslen + [expr {$nbws1 < 0 ? $nbws1 : 0}]}]
   return [list $disp $dispsgr[string repeat { } $nbws1]$symssgr[string\
      repeat { } $nbws2]$mtime]
}

proc formatArrayValToJson {vallist} {
   return [expr {[llength $vallist] > 0 ? "\[ \"[join $vallist {", "}]\" \]"\
      : {[]}}]
}

proc formatObjectValToJson {objlist} {
   foreach {key val isbool} $objlist {
      if {[info exists disp]} {
         append disp {, }
      }
      append disp "\"$key\": "
      if {$isbool} {
         append disp [expr {$val ? {true} : {false}}]
      } else {
         append disp "\"$val\""
      }
   }
   return [expr {[info exists disp] ? "{ $disp }" : "{}"}]
}

# format an element with its syms for a json display in a list
proc formatListEltToJsonDisplay {elt args} {
   set disp "\"$elt\": \{ \"name\": \"$elt\""
   foreach {key vtype val show} $args {
      if {!$show} {
         continue
      }
      append disp ", \"$key\": "
      switch -- $vtype {
         a {append disp [formatArrayValToJson $val]}
         o {append disp [formatObjectValToJson $val]}
         s {append disp "\"$val\""}
      }
   }
   append disp "\}"

   return $disp
}

# Prepare a map list to translate later on a substring in its highlighted
# counterpart. Translate substring into all module it specifies in case of an
# advanced version specification. Each string obtained is right trimmed from
# wildcard. No highlight is set for strings still containing wildcard chars
# after right trim operation. No highlist map is returned at all if highlight
# rendering is disabled.
proc prepareMapToHightlightSubstr {substr} {
   set maplist {}
   if {[sgr hi {}] ne {}} {
      foreach m [getAllModulesFromVersSpec $substr] {
         set m [string trimright $m {*?}]
         if {$m ne {} && [string first * $m] == -1 && [string first ? $m] ==\
            -1} {
            lappend maplist $m [sgr hi $m]
         }
      }
   }
   return $maplist
}

# Format list of modules obtained from a getModules call in upper context
proc reportModules {mod header hsgrkey hstyle show_mtime show_idx\
   one_per_line theader_cols excluded_tag {mod_list_order {}}} {
   # link to the result module list obtained in caller context
   upvar mod_list mod_list

   # output is JSON format
   set json [isStateEqual report_format json]

   # elements to include in output
   set report_sym [isEltInReport sym]
   set report_tag [isEltInReport tag]
   set report_alias [isEltInReport alias]
   # enable variant report if configured or on list json output
   set report_variant [isEltInReport variant [expr {[currentState\
      commandname] eq {list} && $json}]]

   # prepare list of tag abbreviations that can be substituted and list of
   # tags whose name should be colored
   getConf tag_abbrev
   getConf tag_color_name

   # prepare results for display
   set alias_colored [isSgrkeyColored al]
   set default_colored [isSgrkeyColored de]
   set himatchmap [prepareMapToHightlightSubstr $mod]
   set clean_list {}
   set vr_list {}

   # treat elements in specified order if any
   foreach elt [if {[llength $mod_list_order] == 0} {array names mod_list}\
      {set mod_list_order}] {
      if {$report_variant} {
         set vr_list [getVariantList $elt [expr {$json ? 4 : 1}]]
      }
      set sym_list [getVersAliasList $elt]
      # fetch tags but clear excluded tag
      set tag_list [replaceFromList [getTagList $elt] $excluded_tag]
      # abbreviate tags unless for json output
      if {!$json} {
         set tag_list [abbrevTagList $tag_list]
      }
      set dispsgr {}
      # ignore "version" entries as symbolic version are treated
      # along to their relative modulefile not independently
      switch -- [lindex $mod_list($elt) 0] {
         directory {
            if {$json} {
               set dispsgr [formatListEltToJsonDisplay $elt type s directory\
                  1 symbols a $sym_list 1]
            } elseif {$show_mtime} {
               # append / char after name to clearly indicate this is a dir
               lassign [formatListEltToLongDisplay $elt di / $sym_list sy {}\
                  $default_colored $himatchmap] disp dispsgr
            } else {
               lassign [formatListEltToDisplay $elt di / $sym_list sy\
                  $report_sym $default_colored {} 0 {} {} 0 $himatchmap] disp\
                  dispsgr
            }
         }
         modulefile - virtual {
            if {$json} {
               set dispsgr [formatListEltToJsonDisplay $elt type s modulefile\
                  1 variants o $vr_list $report_variant symbols a $sym_list 1\
                  tags a $tag_list 1 pathname s [lindex $mod_list($elt) 2] 1]
            } elseif {$show_mtime} {
               set clock_mtime [expr {[lindex $mod_list($elt) 1] ne {} ?\
                  [clock format [lindex $mod_list($elt) 1] -format {%Y/%m/%d\
                  %H:%M:%S}] : {}}]
               # add to display file modification time in addition
               # to potential syms
               lassign [formatListEltToLongDisplay $elt {} {} $sym_list sy\
                  $clock_mtime $default_colored $himatchmap] disp dispsgr
            } else {
               lassign [formatListEltToDisplay $elt {} {} $sym_list sy\
                  $report_sym $default_colored $tag_list $report_tag $vr_list\
                  va $report_variant $himatchmap] disp dispsgr
            }
         }
         alias {
            if {$json} {
               set dispsgr [formatListEltToJsonDisplay $elt type s alias 1\
                  symbols a $sym_list 1 tags a $tag_list 1 target s [lindex\
                  $mod_list($elt) 1] 1]
            } elseif {$show_mtime} {
               lassign [formatListEltToLongDisplay $elt al " -> [lindex\
                  $mod_list($elt) 1]" $sym_list sy {} $default_colored\
                  $himatchmap] disp dispsgr
            } elseif {$report_alias} {
               # add a '@' sym to indicate elt is an alias if not colored
               if {!$alias_colored} {
                  lappend sym_list @
                  # track use of '@' sym to add it to the output key
                  if {![info exists ::g_used_alias_nocolor]} {
                     set ::g_used_alias_nocolor 1
                  }
               }
               lassign [formatListEltToDisplay $elt al {} $sym_list sy\
                  $report_sym $default_colored $tag_list $report_tag {} {} 0\
                  $himatchmap] disp dispsgr
            }
         }
      }
      if {$dispsgr ne {}} {
         if {$json} {
            lappend clean_list $dispsgr
         } else {
            lappend clean_list $disp
            set sgrmap($disp) $dispsgr
         }
      }
   }

   set len_list {}
   set max_len 0
   if {$json} {
      upvar 0 clean_list display_list
      if {![info exists display_list]} {
         set display_list {}
      }
   } else {
      set display_list {}
      # dictionary-sort results unless if output order is specified
      if {[llength $mod_list_order] == 0} {
         set clean_list [lsort -dictionary $clean_list]
      }
      foreach disp $clean_list {
         # compute display element length list on sorted result
         lappend display_list $sgrmap($disp)
         lappend len_list [set len [string length $disp]]
         if {$len > $max_len} {
            set max_len $len
         }
      }
   }

   # output table header if needed and not yet done
   if {[llength $display_list] > 0 && $show_mtime && ![isStateDefined\
      theader_shown]} {
      setState theader_shown 1
      displayTableHeader {*}$theader_cols
   }

   # output formatted elements
   displayElementList $header $hsgrkey $hstyle $one_per_line $show_idx\
      $display_list $len_list $max_len
}

proc showModulePath {} {
   set modpathlist [getModulePathList]
   if {[llength $modpathlist] > 0} {
      report {Search path for module files (in search order):}
      foreach path $modpathlist {
         report "  [sgr mp $path]"
      }
   } else {
      reportWarning {No directories on module search path}
   }
}

proc displayTableHeader {sgrkey args} {
   foreach {title col_len} $args {
      set col "- [sgr $sgrkey $title] "
      append col [string repeat - [expr {$col_len - [string length $title] -\
         3}]]
      lappend col_list $col
   }

   report [join $col_list .]
}

proc displaySeparatorLine {{title {}} {sgrkey {}}} {
   set tty_cols [getState term_columns]
   if {$title eq {}} {
      # adapt length if screen width is very small
      set max_rep 67
      set rep [expr {$tty_cols > $max_rep ? $max_rep : $tty_cols}]
      report [string repeat - $rep]
   } else {
      set len [string length $title]
      set lrep [tcl::mathfunc::max [expr {($tty_cols - $len - 2)/2}] 1]
      set rrep [tcl::mathfunc::max [expr {$tty_cols - $len - 2 - $lrep}] 1]
      report "[string repeat - $lrep] [sgr $sgrkey $title] [string repeat -\
         $rrep]"
   }
}

# get a list of elements and print them in a column or in a
# one-per-line fashion
proc displayElementList {header sgrkey hstyle one_per_line display_idx\
   display_list {len_list {}} {max_len 0}} {
   set elt_cnt [llength $display_list]
   reportDebug "header=$header, sgrkey=$sgrkey, hstyle=$hstyle,\
      elt_cnt=$elt_cnt, max_len=$max_len, one_per_line=$one_per_line,\
      display_idx=$display_idx"

   # end proc if no element are to print
   if {$elt_cnt == 0} {
      return
   }
   # output is JSON format
   set json [isStateEqual report_format json]

   # display header if any provided
   if {$header ne {noheader}} {
      if {$json} {
         report "\"$header\": \{"
      } elseif {$hstyle eq {sepline}} {
         displaySeparatorLine $header $sgrkey
      } else {
         report [sgr $sgrkey $header]:
      }
   }

   if {$json} {
      set displist [join $display_list ,\n]
   # display one element per line
   } elseif {$one_per_line} {
      if {$display_idx} {
         set idx 1
         foreach elt $display_list {
            append displist [format {%2d) %s } $idx $elt] \n
            incr idx
         }
      } else {
         append displist [join $display_list \n] \n
      }
   # elsewhere display elements in columns
   } else {
      if {$display_idx} {
         # save room for numbers and spacing: 2 digits + ) + space
         set elt_prefix_len 4
      } else {
         set elt_prefix_len 0
      }
      # save room for two spaces after element
      set elt_suffix_len 2

      # compute rows*cols grid size with optimized column number
      # the size of each column is computed to display as much column
      # as possible on each line
      incr max_len $elt_suffix_len
      foreach len $len_list {
         lappend elt_len [incr len $elt_suffix_len]
      }

      set tty_cols [getState term_columns]
      # find valid grid by starting with non-optimized solution where each
      # column length is equal to the length of the biggest element to display
      set cur_cols [tcl::mathfunc::max [expr {int(($tty_cols - \
         $elt_prefix_len) / $max_len)}] 0]
      # when display is found too short to display even one column
      if {$cur_cols == 0} {
         set cols 1
         set rows $elt_cnt
         array set col_width [list 0 $max_len]
      } else {
         set cols 0
         set rows 0
      }
      set last_round 0
      set restart_loop 0
      while {$cur_cols > $cols} {
         if {!$restart_loop} {
            if {$last_round} {
               incr cur_rows
            } else {
               set cur_rows [expr {int(ceil(double($elt_cnt) / $cur_cols))}]
            }
            for {set i 0} {$i < $cur_cols} {incr i} {
               set cur_col_width($i) 0
            }
            for {set i 0} {$i < $cur_rows} {incr i} {
               set row_width($i) 0
            }
            set istart 0
         } else {
            set istart [expr {$col * $cur_rows}]
            # only remove width of elements from current col
            for {set row 0} {$row < ($i % $cur_rows)} {incr row} {
               incr row_width($row) -[expr {$pre_col_width + $elt_prefix_len}]
            }
         }
         set restart_loop 0
         for {set i $istart} {$i < $elt_cnt} {incr i} {
            set col [expr {int($i / $cur_rows)}]
            set row [expr {$i % $cur_rows}]
            # restart loop if a column width change
            if {[lindex $elt_len $i] > $cur_col_width($col)} {
               set pre_col_width $cur_col_width($col)
               set cur_col_width($col) [lindex $elt_len $i]
               set restart_loop 1
               break
            }
            # end search of maximum number of columns if computed row width
            # is larger than terminal width
            if {[incr row_width($row) +[expr {$cur_col_width($col) \
               + $elt_prefix_len}]] > $tty_cols} {
               # start last optimization pass by increasing row number until
               # reaching number used for previous column number, by doing so
               # this number of column may pass in terminal width, if not
               # fallback to previous number of column
               if {$last_round && $cur_rows == $rows} {
                  incr cur_cols -1
               } else {
                  set last_round 1
               }
               break
            }
         }
         # went through all elements without reaching terminal width limit so
         # this number of column solution is valid, try next with a greater
         # column number
         if {$i == $elt_cnt} {
            set cols $cur_cols
            set rows $cur_rows
            array set col_width [array get cur_col_width]
            # number of column is fixed if last optimization round has started
            # reach end also if there is only one row of results
            if {!$last_round && $rows > 1} {
               incr cur_cols
            }
         }

      }
      reportDebug list=$display_list
      reportDebug "rows/cols=$rows/$cols,\
         lastcol_item_cnt=[expr {int($elt_cnt % $rows)}]"

      for {set row 0} {$row < $rows} {incr row} {
         for {set col 0} {$col < $cols} {incr col} {
            set index [expr {$col * $rows + $row}]
            if {$index < $elt_cnt} {
               if {$display_idx} {
                  append displist [format "%2d) " [expr {$index +1}]]
               }
               # cannot use 'format' as strings may contain SGR codes
               append displist [lindex $display_list $index][string repeat\
                  { } [expr {$col_width($col) - [lindex $len_list $index]}]]
            }
         }
         append displist \n
      }
   }
   if {$json && $header ne {noheader}} {
      append displist "\n\}"
   }
   report $displist 1
   reportSeparateNextContent
}

# Report an output key to help understand what the SGR used on this output
# correspond to
proc displayKey {} {
   array set skipsgr [list hi 1 db 1 tr 1 se 1 er 1 wa 1 me 1 in 1 cm 1 va 1]
   array set typesgr [list mp modulepath di [list directory <SGR>/ 10] al\
      module-alias sy [list {symbolic-version} [sgr se (]<SGR>[sgr se )] 18]\
      de [list {default-version}]]

   set display_list {}
   set len_list {}
   foreach key [array names ::g_used_colors] {
      # sgr key matches a basic modulefile type
      if {[info exists typesgr($key)]} {
         # the way to describe key is already defined
         if {[llength $typesgr($key)] > 1} {
            lassign $typesgr($key) desc desctmp len
            set desc [string map [list <SGR> [sgr $key $desc]] $desctmp]
         } else {
            set desc [lindex $typesgr($key) 0]
         }
         if {$key eq {sy} && [info exists ::g_used_sym_nocolor]} {
            unset ::g_used_sym_nocolor
         }
      # key is a tag abbreviation
      } elseif {[info exists ::g_abbrevTag($key)]} {
         set desc $::g_abbrevTag($key)
      # if not part of the ignored list, this key corresponds to a tag name
      } elseif {![info exists skipsgr($key)]} {
         set desc $key
      }
      if {[info exists desc]} {
         # define key description
         if {![info exists len]} {
            set len [string length $desc]
            set desc [sgr $key $desc]
         }
         lappend display_list $desc
         lappend len_list $len
         unset desc
         unset len
      }
   }

   # include var=val key if any other variant form is present in report
   if {![info exists ::g_used_va(val)] && [array exists ::g_used_va]} {
      set ::g_used_va(val) 1
   }
   # add key for variant reports
   if {[info exists ::g_used_va(on)]} {
      lappend display_list "[sgr se \{][sgr va +variant][sgr se\
         \}]=[sgr se \{][sgr va variant=on][sgr se \}]"
      lappend len_list 23
   }
   if {[info exists ::g_used_va(off)]} {
      lappend display_list "[sgr se \{][sgr va -variant][sgr se\
         \}]=[sgr se \{][sgr va variant=off][sgr se \}]"
      lappend len_list 24
   }
   foreach sc [array names ::g_used_va] {
      if {$sc ni {on off val}} {
         lappend display_list "[sgr se \{][sgr va ${sc}value][sgr se\
            \}]=[sgr se \{][sgr va $::g_used_va($sc)=value][sgr se \}]"
         lappend len_list [expr {17 + [string length $::g_used_va($sc)]}]
      }
   }
   # finish with variant=value entry as it is referred by other variant keys
   if {[info exists ::g_used_va(val)]} {
      lappend display_list "[sgr se \{][sgr va variant=value][sgr se \}]"
      lappend len_list 15
   }

   # add key for alias if '@' put in parentheses
   if {[info exists ::g_used_alias_nocolor]} {
      lappend display_list "[sgr se (]@[sgr se )]=module-alias"
      lappend len_list 9
   }
   # add key for symbolic version if any put in parentheses but no color
   if {[info exists ::g_used_sym_nocolor]} {
      lappend display_list "[sgr se (]symbolic-version[sgr se )]"
      lappend len_list 18
   }

   # add key for module tag if any put in angle brackets
   if {[array exists ::g_used_tags]} {
      lappend display_list "[sgr se <]module-tag[sgr se >]"
      lappend len_list 12
   }
   # report translation of each uncolored tag abbreviation that have been used
   foreach tag [array names ::g_used_tags] {
      if {![info exists ::g_used_colors($tag)] && [info exists\
         ::g_abbrevTag($tag)]} {
         lappend display_list [sgr se <]$tag[sgr se >]=$::g_abbrevTag($tag)
         lappend len_list [expr {[string length $tag] + [string length\
            $::g_abbrevTag($tag)] + 3}]
      }
   }

   # find largest element
   set max_len 0
   foreach len $len_list {
      if {$len > $max_len} {
         set max_len $len
      }
   }

   if {[llength $display_list] > 0} {
      # display header
      report Key:
      # display key content
      displayElementList noheader {} {} 0 0 $display_list $len_list $max_len
   }
}

# Return conf value and from where an eventual def value has been overridden
proc displayConfig {val env_var {asked 0} {trans {}} {locked 0}} {
   array set transarr $trans

   # get overridden value and know what has overridden it
   if {$asked} {
      set defby " (cmd-line)"
   } elseif {$env_var ne {} && !$locked && [info exists ::env($env_var)]} {
      set defby " (env-var)"
   } elseif {$locked} {
      set defby " (locked)"
   } else {
      set defby {}
   }

   # translate fetched value if translation table exists
   if {[info exists transarr($val)]} {
      set val $transarr($val)
   }

   return $val$defby
}

proc reportMlUsage {} {
   reportVersion
   report {Usage: ml [options] [command] [args ...]
       ml [options] [[-]modulefile ...]

Examples:
  ml                 equivalent to: module list
  ml foo bar         equivalent to: module load foo bar
  ml -foo -bar baz   equivalent to: module unload foo bar; module load baz
  ml avail -t        equivalent to: module avail -t

See 'module --help' to get available commands and options.}
}

proc reportUsage {} {
   reportVersion
   report {Usage: module [options] [command] [args ...]

Loading / Unloading commands:
  add | load      modulefile [...]  Load modulefile(s)
  try-add | try-load modfile [...]  Load modfile(s), no complain if not found
  rm | unload     modulefile [...]  Remove modulefile(s)
  purge                             Unload all loaded modulefiles
  reload | refresh                  Unload then load all loaded modulefiles
  switch | swap   [mod1] mod2       Unload mod1 and load mod2

Listing / Searching commands:
  list            [-t|-l|-j]        List loaded modules
  avail   [-d|-L] [-t|-l|-j] [-a] [-S|-C] [--indepth|--no-indepth] [mod ...]
                                    List all or matching available modules
  aliases         [-a]              List all module aliases
  whatis [-a] [-j] [modulefile ...] Print whatis information of modulefile(s)
  apropos | keyword | search [-a] [-j] str
                                    Search all name and whatis containing str
  is-loaded       [modulefile ...]  Test if any of the modulefile(s) are loaded
  is-avail        modulefile [...]  Is any of the modulefile(s) available
  info-loaded     modulefile        Get full name of matching loaded module(s)

Collection of modules handling commands:
  save            [collection|file] Save current module list to collection
  restore         [collection|file] Restore module list from collection or file
  saverm          [collection]      Remove saved collection
  saveshow        [collection|file] Display information about collection
  savelist        [-t|-l|-j]        List all saved collections
  is-saved        [collection ...]  Test if any of the collection(s) exists

Environment direct handling commands:
  prepend-path [-d c] var val [...] Prepend value to environment variable
  append-path [-d c] var val [...]  Append value to environment variable
  remove-path [-d c] var val [...]  Remove value from environment variable

Other commands:
  help            [modulefile ...]  Print this or modulefile(s) help info
  display | show  modulefile [...]  Display information about modulefile(s)
  test            [modulefile ...]  Test modulefile(s)
  use     [-a|-p] dir [...]         Add dir(s) to MODULEPATH variable
  unuse           dir [...]         Remove dir(s) from MODULEPATH variable
  is-used         [dir ...]         Is any of the dir(s) enabled in MODULEPATH
  path            modulefile        Print modulefile path
  paths           modulefile        Print path of matching available modules
  clear           [-f]              Reset Modules-specific runtime information
  source          scriptfile [...]  Execute scriptfile(s)
  config [--dump-state|name [val]]  Display or set Modules configuration
  sh-to-mod       shell shellscript [arg ...]
                                    Make modulefile from script env changes
  edit            modulefile        Open modulefile in editor

Switches:
  -t | --terse    Display output in terse format
  -l | --long     Display output in long format
  -j | --json     Display output in JSON format
  -o LIST | --output=LIST
                  Define elements to output on 'avail' or 'list' sub-commands
                  in addition to module names (LIST is made of items like
                  'sym', 'tag' or 'key' separated by ':')
  -a | --all      Include hidden modules in search
  -d | --default  Only show default versions available
  -L | --latest   Only show latest versions available
  -S | --starts-with
                  Search modules whose name begins with query string
  -C | --contains Search modules whose name contains query string
  -i | --icase    Case insensitive match
  -a | --append   Append directory to MODULEPATH (on 'use' sub-command)
  -p | --prepend  Prepend directory to MODULEPATH
  --auto          Enable automated module handling mode
  --no-auto       Disable automated module handling mode
  -f | --force    By-pass dependency consistency or confirmation dialog

Options:
  -h | --help     This usage info
  -V | --version  Module version
  -D | --debug    Enable debug messages
  -T | --trace    Enable trace messages
  -v | --verbose  Enable verbose messages
  -s | --silent   Turn off error, warning and informational messages
  --paginate      Pipe mesg output into a pager if stream attached to terminal
  --no-pager      Do not pipe message output into a pager
  --color[=WHEN]  Colorize the output; WHEN can be 'always' (default if
                  omitted), 'auto' or 'never'
  -w COLS | --width=COLS
                  Set output width to COLS columns.}
}


##############################################################################
# Main -----------------------------------------------------------------------
##############################################################################

# exit in a clean manner by closing interaction with external components
proc cleanupAndExit {code} {
   # finish output document if json format enabled
   if {[isStateEqual report_format json]} {
      # render error messages all together
      if {[info exists ::g_report_erralist]} {
         # ignite report first to get eventual error message from report
         # initialization in order 'foreach' got all messages prior firing
         report "\"errors\": \[" 1
         foreach {sev msg} $::g_report_erralist {
            # split message in lines
            lappend dispmsglist "\n{ \"severity\": \"$sev\", \"message\": \[\
               \"[join [split [charEscaped $msg \"] \n] {", "}]\" \] }"
         }
         report "[join $dispmsglist ,] \]"
      }
      # inhibit next content separator if output is ending
      if {[isStateDefined report_sep_next]} {
         unsetState report_sep_next
      }
      report \}
   }

   # close pager if enabled
   if {[isStateDefined reportfd] && ![isStateEqual reportfd stderr]} {
      catch {flush [getState reportfd]}
      catch {close [getState reportfd]}
   }

   exit $code
}

# runs the global RC files if they exist
proc runModulerc {} {
   set rclist {}

   reportDebug running...

   if {[set rcfile [getConf rcfile]] ne {}} {
      # if MODULERCFILE is a dir, look at a modulerc file in it
      if {[file isdirectory $rcfile]\
         && [file isfile $rcfile/modulerc]} {
         lappend rclist $rcfile/modulerc
      } elseif {[file isfile $rcfile]} {
         lappend rclist $rcfile
      }
   }
   if {[file isfile @etcdir@/rc]} {
      lappend rclist @etcdir@/rc
   }
   if {[info exists ::env(HOME)] && [file isfile $::env(HOME)/.modulerc]} {
      lappend rclist $::env(HOME)/.modulerc
   }

   setState rc_running 1
   foreach rc $rclist {
      if {[file readable $rc]} {
         reportDebug "Executing $rc"
         cmdModuleSource $rc
         lappendState rc_loaded $rc
      }
   }
   unsetState rc_running

   # identify alias or symbolic version set in these global RC files to be
   # able to include them or not in output or resolution processes
   array set ::g_rcAlias [array get ::g_moduleAlias]
   array set ::g_rcVersion [array get ::g_moduleVersion]
   array set ::g_rcVirtual [array get ::g_moduleVirtual]
}

proc aboveCommandName {} {
   return [lindex [getState commandname] end-1]
}

proc ongoingCommandName {commandName} {
   return [expr {[lsearch -exact [getState commandname] $commandName] != -1}]
}

# analyze/translate command name passed to module
proc parseModuleCommandName {command defaultcmd} {
   set cmdempty 0

   # resolve command if alias or shortcut name used
   switch -- $command {
      add               {set command load}
      try-add           {set command try-load}
      rm - remove       {set command unload}
      show              {set command display}
      apropos - keyword {set command search}
      {} {
         # if empty string supplied translate to default command
         set command $defaultcmd
         set cmdempty 1
      }
      default {
         # specific match for shortcut names
         set cmdlen [string length $command]
         foreach {match minlen sccmd} {load 2 load unload 4 unload delete 3\
            unload refresh 3 reload reload 3 reload switch 2 switch swap 2\
            switch display 2 display available 2 avail aliases 2 aliases list\
            2 list whatis 2 whatis purge 2 purge initadd 5 initadd initload 6\
            initadd initprepend 5 initprepend initswitch 6 initswitch\
            initswap 6 initswitch initunload 8 initrm initlist 5 initlist} {
            if {$cmdlen >= $minlen && [string equal -length $cmdlen $command\
               $match]} {
               set command $sccmd
               break
            }
         }
      }
   }

   set cmdvalid [expr {$command in [list load unload reload use unuse source\
      switch display avail aliases path paths list whatis search purge save\
      restore saverm saveshow savelist initadd initprepend initswitch initrm\
      initlist initclear autoinit clear config help test prepend-path\
      append-path remove-path is-loaded is-saved is-used is-avail info-loaded\
      sh-to-mod edit try-load]}]

   return [list $command $cmdvalid $cmdempty]
}

# analyze arg list passed to a module cmd to set options
proc parseModuleCommandArgs {topcall cmd ignerr args} {
   set show_oneperline 0
   set show_mtime 0
   set show_filter {}
   set search_filter [expr {[getConf avail_indepth] ? {} : {noindepth}}]
   set search_match [getConf search_match]
   set dump_state 0
   set addpath_pos prepend
   set not_req 0
   set otherargs {}

   # parse argument list
   foreach arg $args {
      if {[info exists nextargisval]} {
         set $nextargisval $arg
         unset nextargisval
      } elseif {[info exists ignore_next_arg]} {
         unset ignore_next_arg
      } else {
         switch -glob -- $arg {
            -j - --json {
               # enable json output only on supported command
               if {$cmd in [list avail savelist list search whatis]} {
                  setState report_format json
                  set show_oneperline 0
                  set show_mtime 0
               }
            }
            -t - --terse {
               set show_oneperline 1
               set show_mtime 0
               setState report_format terse
            }
            -l - --long {
               set show_mtime 1
               set show_oneperline 0
               setState report_format long
            }
            -o {
               # option is only valid for specific sub-commands
               if {$cmd in [list avail list]} {
                  set nextargisval asked_output
                  set output_arg -o
               } else {
                  if {!$ignerr} {
                     knerror "Unsupported option '$arg' on $cmd sub-command"
                  }
                  set ignore_next_arg 1
               }
            }
            --output=* {
               # option is only valid for specific sub-commands
               if {$cmd in [list avail list]} {
                  set asked_output [string range $arg 9 end]
                  set output_arg --output
               } elseif {!$ignerr} {
                  knerror "Unsupported option '--output' on $cmd sub-command"
               }
            }
            --append - -append {
               if {$cmd eq {use}} {
                  set addpath_pos append
               } else {
                  lappend otherargs $arg
               }
            }
            -p - --prepend - -prepend {
               if {$cmd eq {use}} {
                  set addpath_pos prepend
               } else {
                  lappend otherargs $arg
               }
            }
            --all {
               # include hidden modules only on a limited set of command
               if {$cmd in [list avail aliases search whatis ml list]} {
                  setState hiding_threshold 2
               } else {
                  lappend otherargs $arg
               }
            }
            -a {
               # -a option has a different meaning whether sub-command is use
               # or one of the search/listing sub-commands
               if {$cmd eq {use}} {
                  set addpath_pos append
               } elseif {$cmd in [list avail aliases search whatis ml list]} {
                  setState hiding_threshold 2
               } else {
                  lappend otherargs $arg
               }
            }
            -d - --default {
               # in case of *-path command, -d means --delim
               if {$arg eq {-d} && [string match *-path $cmd]} {
                  lappend otherargs $arg
               } else {
                  set show_filter onlydefaults
               }
            }
            -L - --latest {
               set show_filter onlylatest
            }
            -C - --contains {
               set search_match contains
            }
            -S - --starts-with {
               set search_match starts_with
            }
            --indepth {
               # empty value means 'in depth' as it is default behavior
               set search_filter {}
            }
            --no-indepth {
               set search_filter noindepth
            }
            --dump-state {
               set dump_state 1
            }
            --auto - --no-auto - -f - --force {
               reportWarning "Unsupported option '$arg'"
            }
            --not-req {
               if {!$topcall && $cmd in [list load unload switch]} {
                  set not_req 1
               } else {
                  knerror "Unsupported option '$arg' on $cmd sub-command"
               }
            }
            --output {
               knerror "Missing value for '$arg' option"
            }
            default {
               lappend otherargs $arg
            }
         }
         set prevarg $arg
      }
   }

   if {[info exists nextargisval]} {
      knerror "Missing value for '$prevarg' option"
   }

   if {[info exists asked_output]} {
      if {[getState report_format] in [list long json]} {
         knerror "Unsupported option '$output_arg' on [getState\
            report_format] output mode"
      } else {
         # get config name relative to current sub-command and output format
         set outputconf $cmd
         if {[getState report_format] ne {regular}} {
            append outputconf _[getState report_format]
         }
         append outputconf _output

         # check option value is coherent with current sub-command
         if {[isDiffBetweenList [split $asked_output :] [lindex\
            $::g_config_defs($outputconf) 3]]} {
            if {!$ignerr} {
               knerror "Invalid element in value list for '$output_arg'\
                  option on $cmd sub-command\nAllowed elements are: [lindex\
                  $::g_config_defs($outputconf) 3] (separated by ':')"
            }
         } else {
            set ::asked_$outputconf $asked_output
         }
      }
   }

   reportDebug "(show_oneperline=$show_oneperline, show_mtime=$show_mtime,\
      show_filter=$show_filter, search_filter=$search_filter,\
      search_match=$search_match, dump_state=$dump_state,\
      addpath_pos=$addpath_pos, not_req=$not_req, otherargs=$otherargs)"
   return [list $show_oneperline $show_mtime $show_filter $search_filter\
      $search_match $dump_state $addpath_pos $not_req $otherargs]
}

proc module {command args} {
   set mode [currentState mode]
   reportDebug "cmd='$command', args='$args'"

   # guess if called from top level
   set topcall [expr {[depthState modulename] == 0}]
   set tryhelpmsg [expr {$topcall ? "\nTry 'module --help' for more\
      information." : {}}]
   if {$topcall} {
      set msgprefix {}
   } else {
      set msgprefix {module: }
   }

   # resolve and check command name
   lassign [parseModuleCommandName $command help] command cmdvalid cmdempty
   # clear other args if no command name supplied
   if {$cmdempty} {
      set args {}
   }
   # raise error if supplied command is not known
   if {!$cmdvalid} {
      knerror "${msgprefix}Invalid command '$command'$tryhelpmsg"
   }

   # parse options, do that globally to ignore options not related to a given
   # module sub-command (exclude them from arg list)
   lassign [parseModuleCommandArgs $topcall $command 0 {*}$args]\
      show_oneperline show_mtime show_filter search_filter search_match\
      dump_state addpath_pos not_req args

   # parse module version specification
   defineParseModuleSpecificationProc [getConf advanced_version_spec]
   if {$command in [list avail paths whatis load unload switch help test\
      display path is-avail edit try-load]} {
      set args [parseModuleSpecification 0 {*}$args]
   }

   if {!$topcall} {
      # some commands can only be called from top level, not within modulefile
      switch -- $command {
         path - paths - autoinit - help - prepend-path - append-path -\
         remove-path - is-loaded - is-saved - is-used - is-avail -\
         info-loaded - clear - sh-to-mod - edit {
            knerror "${msgprefix}Command '$command' not supported$tryhelpmsg"
         }
      }
      # other commands can only be called from modulefile evaluated from
      # command acting as top-level context (source and autoinit)
      if {([depthState modulename] > 1 || [currentState commandname] ni [list\
         source autoinit]) && $command eq {config}} {
         knerror "${msgprefix}Command '$command' not supported$tryhelpmsg"
      }
      # no requirement should be recorded this module load/unload/switch cmd
      if {$not_req || ![getConf implicit_requirement]} {
         lappendState inhibit_req_record [currentState evalid]
      }
   }

   # argument number check
   switch -- $command {
      unload - source - display - initadd - initprepend - initrm - test -\
      is-avail - try-load {
         if {[llength $args] == 0} {
            set argnberr 1
         }
      }
      reload - aliases - list - purge - savelist - initlist - initclear -\
      autoinit {
         if {[llength $args] != 0} {
            set argnberr 1
         }
      }
      switch {
         if {[llength $args] == 0 || [llength $args] > 2} {
            set argnberr 1
         }
      }
      path - paths - info-loaded - edit {
         if {[llength $args] != 1} {
            set argnberr 1
         }
      }
      search - save - restore - saverm - saveshow - clear {
         if {[llength $args] > 1} {
            set argnberr 1
         }
      }
      initswitch {
         if {[llength $args] != 2} {
            set argnberr 1
         }
      }
      prepend-path - append-path - remove-path - sh-to-mod {
         if {[llength $args] < 2} {
            set argnberr 1
         }
      }
      config {
         if {[llength $args] > 2} {
            set argnberr 1
         }
      }
   }
   if {[info exists argnberr]} {
      knerror "Unexpected number of args for '$command' command$tryhelpmsg"
   }

   # define if modfile should always be fully read even for validity check
   lappendState always_read_full_file [expr {$command ni [list path paths\
      list avail aliases edit]}]
   lappendState commandname $command
   # is evaluation a regular attempt or a try (silence not found error)
   lappendState try_modulefile [expr {$command eq {try-load}}]

   if {$topcall} {
      # Find and execute any global rc file found
      runModulerc
   }


   switch -- $command {
      load - try-load {
         # ignore flag used in collection to track non-user asked state
         set args [replaceFromList $args --notuasked]
         # no error raised on empty argument list to cope with
         # initadd command that may expect this behavior
         if {[llength $args] > 0} {
            set ret 0
            # if top command is source, consider module load commands made
            # within sourced file evaluation as top load command
            if {$topcall || ([depthState modulename] == 1 && (
               [aboveCommandName] eq {source} || [aboveCommandName] eq\
               {autoinit} || [isStateDefined rc_running]))} {
               set ret [cmdModuleLoad load 1 {*}$args]
            } elseif {$mode eq {load}} {
               # load here if try-load or no auto mode (done through prereq
               # elsewhere, inhibited if currently in DepRe context)
               if {$command eq {try-load} || (![getConf auto_handling] &&\
                  [currentModuleEvalContext] ne {depre})} {
                  # attempt load of not already loaded modules
                  foreach arg $args {
                     if {![is-loaded $arg] && ![is-loading $arg]} {
                        lappend modlist $arg
                     }
                  }
                  if {[info exists modlist]} {
                     set ret [cmdModuleLoad reqlo 0 {*}$modlist]
                     # ignore obtained error if force mode enabled
                     if {[getState force]} {
                        set ret 0
                     }
                  }
               }
               # register modulefiles to load as individual prereqs
               foreach arg $args {
                  # no prereq record if try-load did not succeed
                  if {$command ne {try-load} || [is-loaded $arg]} {
                     prereq $arg
                  }
               }
            # mods unload is handled via UReqUn mechanism when auto enabled
            # (unless if implicit_requirement has been inhibited) also unloads
            # are triggered by ongoing reload, purge or restore commands
            } elseif {(![getConf auto_handling] || [getState\
               inhibit_req_record] eq [currentState evalid]) &&\
               [aboveCommandName] ni [list purge reload restore]} {
               # on unload mode, unload mods in reverse order, if loaded
               # prior this mod, if not user asked and not required by
               # other loaded mods
               set modlist [getLoadedModuleList]
               set modidx [lsearch -exact $modlist [currentState modulename]]
               if {$modidx != 0} {
                  set priormodlist [lrange $modlist 0 $modidx]
                  foreach arg [lreverse $args] {
                     if {[set unmod [getLoadedMatchingName $arg {} 0\
                        $priormodlist]] ne {}} {
                        if {[cmdModuleUnload urequn match 1 0 1 1 $unmod]} {
                           reportWarning "Unload of useless requirement\
                              [getModuleDesignation loaded $unmod] failed" 1
                        }
                     }
                  }
               }
            }
            # sub-module interpretation failed, raise error
            if {$ret && !$topcall} {
               knerror {} MODULES_ERR_SUBFAILED
            }
         }
      }
      unload {
         # if top command is source, consider module load commands made
         # within sourced file evaluation as top load command
         if {$topcall || ([depthState modulename] == 1 && (
            [aboveCommandName] eq {source} || [aboveCommandName] eq\
            {autoinit} || [isStateDefined rc_running]))} {
            set ret [cmdModuleUnload unload match 1 0 0 0 {*}$args]
         } elseif {$mode eq {load}} {
            # unload mods only on load mode, nothing done on unload mode as
            # the registered conflict guarantees the target module cannot
            # be loaded unless forced
            # do not unload module required by others even in force mode
            set ret [cmdModuleUnload conun match 0 0 0 1 {*}$args]

            # register modulefiles to unload as individual conflicts
            foreach arg $args {
               # do not break on error yet, go through the whole modfile
               # evaluation in case conflict is solved later on
               catch {conflict $arg}
            }
            # sub-module interpretation failed, raise error
            if {$ret} {
               knerror {} MODULES_ERR_SUBFAILED
            }
         }
      }
      reload {
         cmdModuleReload
      }
      use {
         if {$topcall || $mode eq {load}} {
            cmdModuleUse $addpath_pos {*}$args
         } else {
            cmdModuleUnuse {*}$args
         }
      }
      unuse {
         cmdModuleUnuse {*}$args
      }
      source {
         if {$topcall || $mode eq {load}} {
            cmdModuleSource {*}$args
         } else {
            # on unload mode, unsource script in reverse order
            cmdModuleUnsource {*}[lreverse $args]
         }
      }
      switch {
         # pass 'user asked state' to switch procedure
         set uasked [expr {$topcall || ([depthState modulename] == 1 &&\
            ([aboveCommandName] eq {source} || [aboveCommandName] eq\
            {autoinit} || [isStateDefined rc_running]))}]
         if {$uasked} {
            cmdModuleSwitch $uasked {*}$args
         } else {
            # CAUTION: it is not recommended to use the `switch`
            # sub-command in modulefiles as this command is intended for
            # the command-line for a 2in1 operation. Could be removed from
            # the modulefile scope in a future release. Use `module unload`
            # and `module load` commands in modulefiles instead.

            switch -- $mode {
               load {
                  cmdModuleSwitch $uasked {*}$args
               }
               unload {
                  # find what has been asked for unload and load
                  lassign $args swunmod swlomod
                  if {$swlomod eq {} && $swunmod ne {}} {
                     set swlomod $swunmod
                  }

                  # apply same mechanisms than for 'module load' and
                  # 'module unload' for an unload evaluation: nothing done
                  # for switched-off module and unload of switched-on
                  # module. If auto handling is enabled switched-on module
                  # is handled via UReqUn mechanism (unless if
                  # implicit_requirement has been inhibited). Also unloads are
                  # triggered by ongoing reload, purge or restore commands
                  if {(![getConf auto_handling] || [getState\
                     inhibit_req_record] eq [currentState evalid]) &&\
                     $swlomod ne {} && [aboveCommandName] ni [list purge\
                     reload restore]} {
                     # unload mod if it was loaded prior this mod, not user
                     # asked and not required by another loaded module
                     set modlist [getLoadedModuleList]
                     set modidx [lsearch -exact $modlist [currentState\
                        modulename]]
                     if {$modidx != 0} {
                        set priormodlist [lrange $modlist 0 $modidx]
                        if {[set unmod [getLoadedMatchingName $swlomod {} 0\
                           $priormodlist]] ne {}} {
                           if {[cmdModuleUnload urequn match 1 0 1 1 $unmod]} {
                              reportWarning "Unload of useless requirement\
                                 [getModuleDesignation loaded $unmod] failed"\
                                 1
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      display {
         cmdModuleDisplay {*}$args
      }
      avail {
         {*}cmdModuleAvail $show_oneperline $show_mtime $show_filter\
            $search_filter $search_match {*}$args
      }
      aliases {
         cmdModuleAliases
      }
      path {
         cmdModulePath {*}$args
      }
      paths {
         cmdModulePaths {*}$args
      }
      list {
         cmdModuleList $show_oneperline $show_mtime
      }
      whatis {
         if {$args ne {}} {
            foreach arg $args {
               cmdModuleWhatIs $arg
            }
         } else {
            cmdModuleWhatIs
         }
      }
      search {
         cmdModuleApropos {*}$args
      }
      purge {
         cmdModulePurge
      }
      save {
         cmdModuleSave {*}$args
      }
      restore {
         cmdModuleRestore {*}$args
      }
      saverm {
         cmdModuleSaverm {*}$args
      }
      saveshow {
         cmdModuleSaveshow {*}$args
      }
      savelist {
         cmdModuleSavelist $show_oneperline $show_mtime
      }
      initadd {
         cmdModuleInit add {*}$args
      }
      initprepend {
         cmdModuleInit prepend {*}$args
      }
      initswitch {
         cmdModuleInit switch {*}$args
      }
      initrm {
         cmdModuleInit rm {*}$args
      }
      initlist {
         cmdModuleInit list {*}$args
      }
      initclear {
         cmdModuleInit clear {*}$args
      }
      autoinit {
         cmdModuleAutoinit
      }
      clear {
         # ensure empty string is correctly passed
         cmdModuleClear [lindex $args 0] [llength $args]
      }
      config {
         cmdModuleConfig $dump_state {*}$args
      }
      sh-to-mod {
         cmdModuleShToMod {*}$args
      }
      edit {
         cmdModuleEdit {*}$args
      }
      help {
         cmdModuleHelp {*}$args
      }
      test {
         cmdModuleTest {*}$args
      }
      prepend-path - append-path - remove-path - is-loaded - is-saved -\
      is-used - is-avail {
         cmdModuleResurface $command {*}$args
      }
      info-loaded {
         cmdModuleResurface module-info loaded {*}$args
      }
   }
   lpopState try_modulefile
   lpopState commandname
   lpopState always_read_full_file

   if {!$topcall && ($not_req || ![getConf implicit_requirement])} {
      lpopState inhibit_req_record
   }

   # if called from top level render settings if any
   if {$topcall} {
      renderSettings
   }

   return {}
}

proc ml {args} {
   # filter out all known options from argument list to guess command name
   # without them in the way
   lassign [parseModuleCommandArgs 1 ml 1 {*}$args] show_oneperline\
      show_mtime show_filter search_filter search_match dump_state\
      addpath_pos not_req fargs

   # determine if first argument is a known module sub-command
   lassign [parseModuleCommandName [lindex $fargs 0] list] command cmdvalid\
      cmdempty

   if {$cmdempty} {
      # consider empty string supplied as first argument as module name
      if {[llength $fargs] > 0} {
         set cmdvalid 0
      }
      set margs $args
   } else {
      # first argument was command name
      set margs [lrange $args 1 end]
   }

   # directly call module procedure if sub-command spotted as first argument
   # or no argument supplied
   if {$cmdvalid} {
      module $command {*}$margs
   } else {
      # parse specified module and get list of mods to unload and mods to load
      defineParseModuleSpecificationProc [getConf advanced_version_spec]
      lassign [parseModuleSpecification 1 {*}$fargs] modunlist modlolist

      # main procedure has already raised error for badly written argument
      # like '-' or '--', but we need here to replay module-specific argument
      # parsing to raise error if some arg are not allowed on unload/load cmd
      set mlcmd [expr {[llength $modunlist] > 0 ? {unload} : {load}}]
      lassign [parseModuleCommandArgs 1 $mlcmd 0 {*}$args] show_oneperline\
         show_mtime show_filter search_filter search_match dump_state\
         addpath_pos not_req fargs

      # define if modfile should always be fully read even for validity check
      lappendState always_read_full_file 1
      lappendState commandname ml
      # is evaluation a regular attempt or a try (silence not found error)
      lappendState try_modulefile [expr {$command eq {try-load}}]

      # Find and execute any global rc file found
      runModulerc

      set ret 0
      pushSettings

      # first unload specified modules
      if {[llength $modunlist] > 0} {
         set ret [cmdModuleUnload unload match 1 0 0 0 {*}$modunlist]
      }
      # then load other modules unless unload phase failed
      if {!$ret && [llength $modlolist] > 0} {
         set ret [cmdModuleLoad load 1 {*}$modlolist]
      }

      # rollback changes if any load or unload failed
      if {$ret} {
         restoreSettings
      }
      popSettings

      lpopState try_modulefile
      lpopState commandname
      lpopState always_read_full_file

      renderSettings
   }

   return {}
}

#
# Main program
#

# needed on a gentoo system. Shouldn't hurt since it is
# supposed to be the default behavior
fconfigure stderr -translation auto

if {[catch {
   # parse all command-line arguments before doing any action, no output is
   # made during argument parse to wait for potential paging to be setup
   set show_help 0
   set show_version 0
   setState cmdline "$argv0 $argv"

   # Load extension library if enabled
   @libtclenvmodules@if {[file readable [getConf tcl_ext_lib]]} {
   @libtclenvmodules@   reportDebug "Load Tcl extension library ([getConf tcl_ext_lib])"
   @libtclenvmodules@   load [file normalize [getConf tcl_ext_lib]] Envmodules
   @libtclenvmodules@   setState tcl_ext_lib_loaded 1
   @libtclenvmodules@}
   # use fallback procs if extension library is not loaded
   if {[info commands readFile] eq {}} {
      rename ::__readFile ::readFile
      rename ::__getFilesInDirectory ::getFilesInDirectory
      rename ::__initStateUsergroups ::initStateUsergroups
      rename ::__initStateUsername ::initStateUsername
      rename ::__initStateClockSeconds ::initStateClockSeconds
      rename ::__parseDateTimeArg ::parseDateTimeArg
   }

   # source site configuration script if any
   sourceSiteConfig

   # Parse shell
   setState shell [lindex $argv 0]
   switch -- [getState shell] {
      sh - bash - ksh - zsh {
         setState shelltype sh
      }
      csh - tcsh {
         setState shelltype csh
      }
      fish - cmd - tcl - perl - python - ruby - lisp - cmake - r {
         setState shelltype [getState shell]
      }
      default {
         reportErrorAndExit "Unknown shell type \'([getState shell])\'"
      }
   }

   # extract options and command switches from other args
   set otherargv {}
   set extraargv {}
   set ddelimarg 0
   # split first arg if multi-word string detected for compat with previous
   # doc on module usage with scripting language: module('load mod1 mod2')
   set argtoparse [if {[llength [lindex $argv 1]] > 1} {list {*}[split\
      [lindex $argv 1]] {*}[lrange $argv 2 end]} {lrange $argv 1 end}]
   foreach arg $argtoparse {
      if {[info exists ignore_next_arg]} {
         unset ignore_next_arg
      } elseif {[info exists nextargisextraargv]} {
         lappend extraargv $arg
         unset nextargisextraargv
      } elseif {[info exists nextargisval]} {
         set $nextargisval $arg
         unset nextargisval
      } else {
         switch -glob -- $arg {
            -T - --trace {
               set asked_verbosity trace
            }
            -D - -DD - --debug {
               set asked_verbosity [expr {$arg eq {-DD} || ([info exists\
                  asked_verbosity] && $asked_verbosity in {debug debug2}) ?\
                  {debug2} : {debug}}]
            }
            -s - --silent {
               set asked_verbosity silent
            }
            -v - -vv - --verbose {
               set asked_verbosity [expr {$arg eq {-vv} || ([info exists\
                  asked_verbosity] && $asked_verbosity in {verbose verbose2})\
                  ? {verbose2} : {verbose}}]
            }
            --help - -h {
               set show_help 1
            }
            -V - --version {
               set show_version 1
            }
            --paginate {
               set asked_paginate 1
            }
            --no-pager {
               set asked_paginate 0
            }
            --auto {
               set asked_auto_handling 1
            }
            --no-auto {
               set asked_auto_handling 0
            }
            -f - --force {
               set asked_force 1
            }
            --color* {
               set asked_color [string range $arg 8 end]
               if {$asked_color eq {}} {
                  set asked_color always
               } elseif {$asked_color ni [lindex $::g_config_defs(color) 3]} {
                  unset asked_color
               }
            }
            -o {
               # add with next arg to the command-specific switches
               lappend extraargv $arg
               set nextargisextraargv 1
            }
            --width* {
               set asked_term_width [string range $arg 8 end]
               set  term_width_arg --width
               if {$asked_term_width eq {}} {
                  set asked_term_width 0
               }
            }
            -w {
               set nextargisval asked_term_width
               set  term_width_arg -w
            }
            -t - --terse - -l - --long - --default - -L - --latest - -S -\
            --starts-with - -C - --contains - -j - --json - --output=* {
               # command-specific switches that can for compatibility be
               # passed before the command name, so add them to a specific
               # arg list to ensure command name as first position argument
               lappend extraargv $arg
            }
            -d {
               # in case of *-path command, -d means --delim
               if {$ddelimarg} {
                  lappend otherargv $arg
               } else {
                  lappend extraargv $arg
               }
            }
            -a - --append - -append - --all - -p - --prepend - -prepend -\
            --delim - -delim - --delim=* - -delim=* - --duplicates - --index\
            - --notuasked - --indepth - --no-indepth - --dump-state -\
            --reset {
               # command-specific switches interpreted later on
               lappend otherargv $arg
            }
            append-path - prepend-path - remove-path {
               # detect *-path commands to say -d means --delim, not --default
               set ddelimarg 1
               lappend otherargv $arg
            }
            -i - --icase {
               set asked_icase always
            }
            --human - -c - --create - --userlvl=* {
               # ignore C-version specific option, no error only warning
               reportWarning "Unsupported option '$arg'"
            }
            -u - --userlvl {
               reportWarning "Unsupported option '$arg'"
               # also ignore argument value
               set ignore_next_arg 1
            }
            --output {
               reportErrorAndExit "Missing value for '$arg' option\nTry\
                  'module --help' for more information."
            }
            {-} - {--} - {--*} {
               reportErrorAndExit "Invalid option '$arg'\nTry 'module --help'\
                  for more information."
            }
            -* {
               # verify current command accepts minus arg (-*)
               if {![info exists accept_minus_arg] && [llength $otherargv]\
                  > 0} {
                  set subcmdtest [lindex $otherargv 0]
                  if {$subcmdtest ne {ml}} {
                     lassign [parseModuleCommandName $subcmdtest {}]\
                        subcmdtest
                  }
                  # accepted if command is ml or if adv vers spec is enabled
                  # and command can receive boolean variant specification
                  set accept_minus_arg [expr {$subcmdtest eq {ml} ||\
                     ([getConf advanced_version_spec] && $subcmdtest in\
                     {avail display help is-avail is-loaded load path paths\
                     switch test unload whatis})}]
               }
               # spare argument if minus arg is accepted
               if {[info exists accept_minus_arg] && $accept_minus_arg} {
                  lappend otherargv $arg
               } else {
                  reportErrorAndExit "Invalid option '$arg'\nTry 'module\
                     --help' for more information."
               }
            }
            default {
               lappend otherargv $arg
            }
         }
         set prevarg $arg
      }
   }

   if {[info exists nextargisextraargv]} {
      reportErrorAndExit "Missing value for '$prevarg' option\nTry 'module\
         --help' for more information."
   }
   if {[info exists asked_term_width]} {
      set rangewidth [lindex $::g_config_defs(term_width) 3]
      if {[string is integer -strict $::asked_term_width] && \
         $::asked_term_width >= [lindex $rangewidth 0] &&\
         $::asked_term_width <= [lindex $rangewidth 1]} {
         set validval 1
      } else {
         reportErrorAndExit "Invalid value for option\
            '$term_width_arg'\nValue should be an integer comprised between\
            [lindex $rangewidth 0] and [lindex $rangewidth 1]"
      }
   }

   setState subcmd [lindex $otherargv 0]
   set otherargv [list {*}[lreplace $otherargv 0 0] {*}$extraargv]
   setState subcmd_args $otherargv
   # call ml frontend if it is asked command
   if {[getState subcmd] eq {ml}} {
      set execcmdlist [list ml {*}$otherargv]
   } else {
      set execcmdlist [list module [getState subcmd] {*}$otherargv]
   }

   # now options are known initialize error report (start pager if enabled)
   initErrorReport

   # put back quarantine variables in env, if quarantine mechanism supported
   @quarantinesupport@if {[getConf run_quarantine] ne {} && [getState shelltype] ne {csh}} {
   @quarantinesupport@   foreach var [split [getConf run_quarantine]] {
   @quarantinesupport@      # check variable name is valid
   @quarantinesupport@      if {[regexp {^[A-Za-z_][A-Za-z0-9_]*$} $var]} {
   @quarantinesupport@         set quarvar __MODULES_QUAR_${var}
   @quarantinesupport@         # put back value
   @quarantinesupport@         if {[info exists env($quarvar)]} {
   @quarantinesupport@            reportDebug "Release '$var' environment variable from\
                  quarantine ($env($quarvar))"
   @quarantinesupport@            set env($var) $env($quarvar)
   @quarantinesupport@            unset env($quarvar)
   @quarantinesupport@         # or unset env var if no value found in quarantine
   @quarantinesupport@         } elseif {[info exists env($var)]} {
   @quarantinesupport@            reportDebug "Unset '$var' environment variable after\
                  quarantine"
   @quarantinesupport@            unset env($var)
   @quarantinesupport@         }
   @quarantinesupport@      } elseif {[string length $var] > 0} {
   @quarantinesupport@         reportWarning "Bad variable name set in MODULES_RUN_QUARANTINE\
               ($var)"
   @quarantinesupport@      }
   @quarantinesupport@   }
   @quarantinesupport@}

   if {$show_help} {
      if {[getState subcmd] eq {ml}} {
         reportMlUsage
      } else {
         reportUsage
      }
      cleanupAndExit 0
   }
   if {$show_version} {
      reportVersion
      cleanupAndExit 0
   }

   # no modulefile is currently being interpreted
   lappendState modulefile {}

   # eval needed to pass otherargv as list to module proc
   {*}$execcmdlist
} errMsg ]} {
   # re-enable error report in case it was previously inhibited
   setState inhibit_errreport 0
   # remove any message record id to render next error
   clearAllMsgRecordId
   # render error if not done yet
   if {$errorCode ne {MODULES_ERR_RENDERED}} {
      raiseErrorCount
      renderFalse
   }
   # report stack trace in addition to the error message if error is unknown
   if {$errorCode ni [list MODULES_ERR_RENDERED MODULES_ERR_KNOWN]} {
      set errMsg "$errorInfo\n[sgr hi {Please report this issue at\
         https://github.com/cea-hpc/modules/issues}]"
   }
   reportError $errMsg
   # init error report here in case the error raised before the regular init
   initErrorReport
   cleanupAndExit 1
}

cleanupAndExit 0

# ;;; Local Variables: ***
# ;;; mode:tcl ***
# ;;; End: ***
# vim:set tabstop=3 shiftwidth=3 expandtab autoindent:
