##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		modules.50-cmds/%M%
#   Revision:		%I%
#   First Edition:	2018/06/06
#   Last Mod.:		%U%, %G%
#
#   Authors:		Xavier Delaruelle, xavier.delaruelle@cea.fr
#
#   Description:	Testuite testsequence
#   Command:        load, unload
#   Modulefiles:
#   Sub-Command:    prereq, conflict
#
#   Comment:	%C{
#           Test automatic resolution of modulefile dependencies when the
#           auto-handling mode is enabled (dependent modules handling)
#		}C%
#
##############################################################################

# enable auto_handling with environment variable
setenv_var MODULES_AUTO_HANDLING 1

set mp "$modpath.deps"

# setup specific environment
setenv_path_var MODULEPATH $mp

# test correct dependency resolution
set ans [list]
lappend ans [list setpath LOADEDMODULES "ca:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/ca:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
lappend ans [list setpath MODULES_LMNOTUASKED "ca:cc:cd:cf"]
set tserr [list "load ca" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "load ce cg" $ans [join $tserr "\n"]

# set environment with above result
setenv_loaded_module [list ca cc cd ce cf cg] [list "$mp/ca" "$mp/cc" "$mp/cd" "$mp/ce" "$mp/cf" "$mp/cg"] [list ca cc cd cf]
setenv_path_var MODULES_LMPREREQ "cc&ca|cb" "cd&cc" "ce&cd" "cf&cc" "cg&cf"

# load optional prereq module (alternative module was loaded automatically)
set ans [list]
lappend ans [list setpath LOADEDMODULES "ca:cb:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/ca:$mp/cb:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
# LMPREREQ and LMNOTUASKED are updated as dependencies are reloaded
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
lappend ans [list setpath MODULES_LMNOTUASKED "ca:cc:cd:cf"]
set tserr [list "unload cg" "unload cf" "unload ce" "unload cd" "unload cc" "load cb" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "load cb" $ans [join $tserr "\n"]

# set environment where every module has been asked by user
setenv_loaded_module [list ca cc cd ce cf cg] [list "$mp/ca" "$mp/cc" "$mp/cd" "$mp/ce" "$mp/cf" "$mp/cg"]
setenv_path_var MODULES_LMPREREQ "cc&ca|cb" "cd&cc" "ce&cd" "cf&cc" "cg&cf"

# load optional prereq module (every module loaded by user)
set ans [list]
lappend ans [list setpath LOADEDMODULES "ca:cb:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/ca:$mp/cb:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
# LMPREREQ is updated as dependencies are reloaded
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
set tserr [list "unload cg" "unload cf" "unload ce" "unload cd" "unload cc" "load cb" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "load cb" $ans [join $tserr "\n"]


# test with alternative prereq already loaded (asked by user)
setenv_loaded_module [list cb] [list "$mp/cb"]
unsetenv_path_var MODULES_LMPREREQ

set ans [list]
lappend ans [list setpath LOADEDMODULES "cb:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/cb:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
lappend ans [list setpath MODULES_LMNOTUASKED "cc:cd:cf"]
set tserr [list "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "load ce cg" $ans [join $tserr "\n"]

# set environment with above result
setenv_loaded_module [list cb cc cd ce cf cg] [list "$mp/cb" "$mp/cc" "$mp/cd" "$mp/ce" "$mp/cf" "$mp/cg"] [list cc cd cf]
setenv_path_var MODULES_LMPREREQ "cc&ca|cb" "cd&cc" "ce&cd" "cf&cc" "cg&cf"

# load optional first-in-list prereq module
set ans [list]
lappend ans [list setpath LOADEDMODULES "cb:ca:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/cb:$mp/ca:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
# LMPREREQ and LMNOTUASKED are updated as dependencies are reloaded
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
lappend ans [list setpath MODULES_LMNOTUASKED "cc:cd:cf"]
set tserr [list "unload cg" "unload cf" "unload ce" "unload cd" "unload cc" "load ca" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "load ca" $ans [join $tserr "\n"]

# set environment where every module has been asked by user
setenv_loaded_module [list cb cc cd ce cf cg] [list "$mp/cb" "$mp/cc" "$mp/cd" "$mp/ce" "$mp/cf" "$mp/cg"]
setenv_path_var MODULES_LMPREREQ "cc&ca|cb" "cd&cc" "ce&cd" "cf&cc" "cg&cf"

# load optional first-in-list prereq module (every module loaded by user)
set ans [list]
lappend ans [list setpath LOADEDMODULES "cb:ca:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/cb:$mp/ca:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
# LMPREREQ is updated as dependencies are reloaded
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
set tserr [list "unload cg" "unload cf" "unload ce" "unload cd" "unload cc" "load ca" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "load ca" $ans [join $tserr "\n"]


# set environment with both optional prereq loaded
setenv_loaded_module [list ca cb cc cd ce cf cg] [list "$mp/ca" "$mp/cb" "$mp/cc" "$mp/cd" "$mp/ce" "$mp/cf" "$mp/cg"] [list ca cc cd cf]
setenv_path_var MODULES_LMPREREQ "cc&ca|cb" "cd&cc" "ce&cd" "cf&cc" "cg&cf"

# unload optional first-in-list prereq module
set ans [list]
lappend ans [list setpath LOADEDMODULES "cb:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/cb:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
# LMPREREQ and LMNOTUASKED are updated as dependencies are reloaded
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
lappend ans [list setpath MODULES_LMNOTUASKED "cc:cd:cf"]
set tserr [list "unload cg" "unload cf" "unload ce" "unload cd" "unload cc" "unload ca" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "unload ca" $ans [join $tserr "\n"]

# unload optional second-in-list prereq module
set ans [list]
lappend ans [list setpath LOADEDMODULES "ca:cc:cd:ce:cf:cg"]
lappend ans [list setpath _LMFILES_ "$mp/ca:$mp/cc:$mp/cd:$mp/ce:$mp/cf:$mp/cg"]
# LMPREREQ and LMNOTUASKED are updated as dependencies are reloaded
lappend ans [list setpath MODULES_LMPREREQ "cc&ca|cb:cd&cc:ce&cd:cf&cc:cg&cf"]
lappend ans [list setpath MODULES_LMNOTUASKED "ca:cc:cd:cf"]
set tserr [list "unload cg" "unload cf" "unload ce" "unload cd" "unload cc" "unload cb" "load cc" "load cd" "load ce" "load cf" "load cg"]
testouterr_cmd_re "sh" "unload cb" $ans [join $tserr "\n"]


# restore environment
unsetenv_path_var MODULES_LMPREREQ
unsetenv_loaded_module

# test load of first-operational-in-list prereq module
set ans [list]
lappend ans [list setpath LOADEDMODULES "dd:df:dg"]
lappend ans [list setpath _LMFILES_ "$mp/dd:$mp/df:$mp/dg"]
lappend ans [list setpath MODULES_LMNOTUASKED "dd:df"]
lappend ans [list setpath MODULES_LMCONFLICT "dg&db"]
lappend ans [list setpath MODULES_LMPREREQ "df&da|db|dc|dd|de:dg&df"]
lappend ans [list ERR]
set tserr [list [err_conflictw da df] "$error_msgs: [err_conflict db dg]" "load dc" "load dd" "load df" "load dg"]
testouterr_cmd_re "sh" "load dg" $ans [join $tserr "\n"]

# test with alternative prereq already loaded (asked by user)
setenv_loaded_module [list de] [list "$mp/de"]

# test load of first-operational-in-list prereq module with alternative prereq already loaded
set ans [list]
lappend ans [list setpath LOADEDMODULES "de:df:dg"]
lappend ans [list setpath _LMFILES_ "$mp/de:$mp/df:$mp/dg"]
lappend ans [list setpath MODULES_LMNOTUASKED "df"]
lappend ans [list setpath MODULES_LMCONFLICT "dg&db"]
lappend ans [list setpath MODULES_LMPREREQ "df&da|db|dc|dd|de:dg&df"]
set tserr [list "load df" "load dg"]
testouterr_cmd_re "sh" "load dg" $ans [join $tserr "\n"]

# set environment where every module has been asked by user
setenv_loaded_module [list de df dg] [list "$mp/de" "$mp/df" "$mp/dg"]
setenv_path_var MODULES_LMPREREQ "df&da|db|dc|dd|de" "dg&df"
setenv_path_var MODULES_LMCONFLICT "dg&db"

# attempt to unload first-operational-in-list prereq module
set ans [list]
lappend ans [list unsetpath LOADEDMODULES]
lappend ans [list unsetpath _LMFILES_]
lappend ans [list unsetpath MODULES_LMCONFLICT]
lappend ans [list unsetpath MODULES_LMPREREQ]
set tserr [list "unload dg" "unload df" "unload de"]
testouterr_cmd_re "sh" "unload de" $ans [join $tserr "\n"]


# tests with prereq suite fully loaded
setenv_loaded_module [list dd df dg] [list "$mp/dd" "$mp/df" "$mp/dg"] [list dd df]
setenv_path_var MODULES_LMPREREQ "df&da|db|dc|dd|de" "dg&df"
setenv_path_var MODULES_LMCONFLICT "dg&db"

# attempt to load broken/conflicting prereq alternative
set ans [list]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list setpath _LMFILES_ "$mp/dd:$mp/da"]
lappend ans [list setpath LOADEDMODULES "dd:da"]
lappend ans [list setpath MODULES_LMNOTUASKED "dd"]
lappend ans [list setpath MODULES_LMCONFLICT "da&df"]
lappend ans [list ERR]
# dependent modules are unloaded prior "da" load but cannot be reloaded as "da" declares a conflict on them
set tserr [list "unload dg" "unload df" "load da" "$error_msgs: [err_conflict df da]" [err_prereq dg df]]
testouterr_cmd_re "sh" "load da" $ans [join $tserr "\n"]
testouterr_cmd_re "sh" "load db" "ERR" "$error_msgs: [err_conflict db dg]"
# dependent modules are unloaded prior "dc" load but as dc breaks everything is restored
set tserr [list "unload dg" "unload df" "load dc"]
testouterr_cmd_re "sh" "load dc" "ERR" [join $tserr "\n"]


# tests with one module missing from prereq suite
setenv_loaded_module [list df dg] [list "$mp/df" "$mp/dg"]
setenv_path_var MODULES_LMPREREQ "df&da|db|dc|dd|de" "dg&df"
setenv_path_var MODULES_LMCONFLICT "dg&db"

# attempt to load broken/conflicting module solving missing prereq requirement
set ans [list]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list setpath _LMFILES_ "$mp/da"]
lappend ans [list setpath LOADEDMODULES "da"]
lappend ans [list setpath MODULES_LMCONFLICT "da&df"]
lappend ans [list ERR]
# dependent modules are unloaded prior "da" load but cannot be reloaded as "da" declares a conflict on them
set tserr [list "unload dg" "unload df" "load da" "$error_msgs: [err_conflict df da]" [err_prereq dg df]]
testouterr_cmd_re "sh" "load da" $ans [join $tserr "\n"]
testouterr_cmd_re "sh" "load db" "ERR" "$error_msgs: [err_conflict db dg]"
# dependent modules are unloaded prior "dc" load but as dc breaks everything is restored
set tserr [list "unload dg" "unload df" "load dc"]
testouterr_cmd_re "sh" "load dc" "ERR" [join $tserr "\n"]
set ans [list]
lappend ans [list setpath LOADEDMODULES "dd:df:dg"]
lappend ans [list setpath _LMFILES_ "$mp/dd:$mp/df:$mp/dg"]
lappend ans [list setpath MODULES_LMCONFLICT "dg&db"]
lappend ans [list setpath MODULES_LMPREREQ "df&da|db|dc|dd|de:dg&df"]
set tserr [list "unload dg" "unload df" "load dd" "load df" "load dg"]
testouterr_cmd_re "sh" "load dd" $ans [join $tserr "\n"]


# test reload dependent mechanism order with modulefiles looking at currently loaded prereqs to define variable
setenv_loaded_module [list g1 g4] [list "$mp/g1" "$mp/g4"]
setenv_path_var MODULES_LMPREREQ "g4&g1|g2|g3"
unsetenv_path_var MODULES_LMCONFLICT
setenv_path_var FOO "/path/to/g4-g1"

set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g1-g2"]
lappend ans [list setpath LOADEDMODULES "g1:g2:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g1:$mp/g2:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
testouterr_cmd_re "sh" "load g2" $ans ""

set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g2"]
lappend ans [list setpath LOADEDMODULES "g2:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g2:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
testouterr_cmd_re "sh" "switch g1 g2" $ans ""

# unload test that creates a prereq violation
set ans [list]
lappend ans [list setpath LOADEDMODULES "g4"]
lappend ans [list setpath _LMFILES_ "$mp/g4"]
testouterr_cmd_re "sh" "unload --force --no-auto g1" $ans [err_prerequnf g1 g4]

# set loaded situation where a prereq violation exists
setenv_loaded_module [list g4] [list "$mp/g4"]

# load test that solves a prereq violation
set ans [list]
lappend ans [list set FOO "/path/to/g4-g1"]
lappend ans [list set FOO_modshare "/path/to/g4-g1:2"]
lappend ans [list setpath LOADEDMODULES "g1:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g1:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
# g4 unload phase did not correctly unset path in FOO (double reference to g1 path)
testouterr_cmd_re "sh" "load g1" $ans ""

set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g2:/path/to/g4-g1"]
lappend ans [list setpath LOADEDMODULES "g2:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g2:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
# g4 unload phase did not correctly unset path in FOO (still reference to g1 path)
testouterr_cmd_re "sh" "load g2" $ans ""

# set loaded situation with multiple optional prereqs loaded
setenv_loaded_module [list g1 g2 g4] [list "$mp/g1" "$mp/g2" "$mp/g4"]
setenv_path_var FOO "/path/to/g4-g1-g2"

set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g2"]
lappend ans [list setpath LOADEDMODULES "g2:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g2:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
testouterr_cmd_re "sh" "unload g1" $ans ""

# load test that creates a conflict violation
set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g1-g2-g3"]
lappend ans [list setpath LOADEDMODULES "g1:g2:g3:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g1:$mp/g2:$mp/g3:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
lappend ans [list setpath MODULES_LMCONFLICT "g3&g2"]
testouterr_cmd_re "sh" "load --force g3" $ans [err_conflictf g3 g2]

# set loaded situation where a conflict violation exists
setenv_loaded_module [list g1 g2 g3 g4] [list "$mp/g1" "$mp/g2" "$mp/g3" "$mp/g4"]
setenv_path_var MODULES_LMCONFLICT "g3&g2"
setenv_path_var FOO "/path/to/g4-g1-g2-g3"

# unload test that solves a conflict violation
set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g1-g2"]
lappend ans [list setpath LOADEDMODULES "g1:g2:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g1:$mp/g2:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
lappend ans [list unsetpath MODULES_LMCONFLICT]
testouterr_cmd_re "sh" "unload g3" $ans ""

# set loaded situation where a conflict violation exists on main module
setenv_loaded_module [list g1 g2 g4 g5] [list "$mp/g1" "$mp/g2" "$mp/g4" "$mp/g5"]
setenv_path_var MODULES_LMCONFLICT "g5&g4"
setenv_path_var FOO "/path/to/g4-g1-g2"

# as conflict exist, main module is not reloaded whereas one of its optional prereq has been unloaded
set ans [list]
lappend ans [list setpath LOADEDMODULES "g1:g4:g5"]
lappend ans [list setpath _LMFILES_ "$mp/g1:$mp/g4:$mp/g5"]
testouterr_cmd_re "sh" "unload g2" $ans ""

# set previous result as loaded situation
setenv_loaded_module [list g1 g4 g5] [list "$mp/g1" "$mp/g4" "$mp/g5"]

# although conflict is solved g4 is not able to correctly unset previous FOO value as it was not
# updated when conflict violation was there
set ans [list]
lappend ans [list setpath FOO "/path/to/g4-g1:/path/to/g4-g1-g2"]
lappend ans [list setpath LOADEDMODULES "g1:g4"]
lappend ans [list setpath _LMFILES_ "$mp/g1:$mp/g4"]
lappend ans [list setpath MODULES_LMPREREQ "g4&g1|g2|g3"]
lappend ans [list unsetpath MODULES_LMCONFLICT]
testouterr_cmd_re "sh" "unload g5" $ans ""


# test situation where an automatically loaded prereq (h1) of a module currently being unloaded (h2)
# is also a prereq of a module (h4) optionally dependent of the module being unloaded, this prereq
# (h1) should not be considered unloadable as it is still needed by the dependent module (h4)
setenv_loaded_module [list h1 h2 h3 h4] [list "$mp/h1" "$mp/h2" "$mp/h3" "$mp/h4"] [list h1]
setenv_path_var MODULES_LMPREREQ "h2&h1" "h4&h1&h2|h3"
unsetenv_path_var MODULES_LMCONFLICT

set ans [list]
lappend ans [list setpath LOADEDMODULES "h1:h3:h4"]
lappend ans [list setpath _LMFILES_ "$mp/h1:$mp/h3:$mp/h4"]
lappend ans [list setpath MODULES_LMPREREQ "h4&h1&h2|h3"]
set tserr [list "unload h4" "unload h2" "load h4"]
testouterr_cmd_re "sh" "unload h2" $ans [join $tserr "\n"]


# test situation where a useless requirement module is also a requirement of another useless requirement module
setenv_loaded_module [list h10 h11 h12] [list "$mp/h10" "$mp/h11" "$mp/h12"] [list h10 h11]
setenv_path_var MODULES_LMPREREQ "h11&h10" "h12&h11&h10"

set ans [list]
lappend ans [list unsetpath LOADEDMODULES]
lappend ans [list unsetpath _LMFILES_]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list unsetpath MODULES_LMNOTUASKED]
set tserr [list "unload h12" "unload h11" "unload h10"]
testouterr_cmd_re "sh" "unload h12" $ans [join $tserr "\n"]


# test situation where useless requirement modules are interconnected but everything should be unloaded when top module is unloaded
setenv_loaded_module [list h20 h21 h22 h23 h24 h25] [list "$mp/h20" "$mp/h21" "$mp/h22" "$mp/h23" "$mp/h24" "$mp/h25"] [list h20 h21 h22 h23 h24]
setenv_path_var MODULES_LMPREREQ "h21&h20" "h22&h21" "h23&h21" "h24&h23" "h25&h21&h22&h24"

set ans [list]
lappend ans [list unsetpath LOADEDMODULES]
lappend ans [list unsetpath _LMFILES_]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list unsetpath MODULES_LMNOTUASKED]
set tserr [list "unload h25" "unload h24" "unload h23" "unload h22" "unload h21" "unload h20"]
testouterr_cmd_re "sh" "unload h25" $ans [join $tserr "\n"]


# test situations where candidate useless requirement modules still hold an optional dependency link
# useless requirement module candidate is still optional requirement of another module, no unload
setenv_loaded_module [list h30 h31 h32 h34 h35] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h34" "$mp/h35"] [list h30 h31]
setenv_path_var MODULES_LMPREREQ "h31&h30" "h32&h31" "h35&h34|h31"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h30:h31:h34:h35"]
lappend ans [list setpath _LMFILES_ "$mp/h30:$mp/h31:$mp/h34:$mp/h35"]
lappend ans [list setpath MODULES_LMPREREQ "h31&h30:h35&h34|h31"]
set tserr [list "unload h32"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]

# useless requirement module candidate is still optional requirement of another module, no unload
# but main module was also optional requirement, so dependent is reloaded
setenv_loaded_module [list h30 h31 h32 h34 h36] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h34" "$mp/h36"] [list h30 h31]
setenv_path_var MODULES_LMPREREQ "h31&h30" "h32&h31" "h36&h34|h30|h32"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h30:h34:h36"]
lappend ans [list setpath _LMFILES_ "$mp/h30:$mp/h34:$mp/h36"]
lappend ans [list setpath MODULES_LMPREREQ "h36&h34|h30|h32"]
lappend ans [list setpath MODULES_LMNOTUASKED "h30"]
set tserr [list "unload h36" "unload h32" "unload h31" "load h36"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]

# useless requirement module candidates are both still optional requirement of another module, no unload
setenv_loaded_module [list h30 h31 h32 h34 h37] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h34" "$mp/h37"] [list h30 h31]
setenv_path_var MODULES_LMPREREQ "h31&h30" "h32&h31" "h37&h34|h30|h31"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h30:h31:h34:h37"]
lappend ans [list setpath _LMFILES_ "$mp/h30:$mp/h31:$mp/h34:$mp/h37"]
lappend ans [list setpath MODULES_LMPREREQ "h31&h30:h37&h34|h30|h31"]
set tserr [list "unload h32"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]


# test situations where unload of useless requirement modules triggers reload of conflicting module
# unload of a useless requirement module solves a conflict violation
setenv_loaded_module [list h30 h31 h32 h33] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h33"] [list h30 h31]
setenv_path_var MODULES_LMPREREQ "h31&h30" "h32&h31"
setenv_path_var MODULES_LMCONFLICT "h33&h31"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h33"]
lappend ans [list setpath _LMFILES_ "$mp/h33"]
lappend ans [list setpath MODULES_LMCONFLICT "h33&h31"]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list unsetpath MODULES_LMNOTUASKED]
set tserr [list "unload h33" "unload h32" "unload h31" "unload h30" "load h33"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]

# unload of two useless requirement modules solves a conflict violation
setenv_loaded_module [list h30 h31 h32 h38] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h38"] [list h30 h31]
setenv_path_var MODULES_LMCONFLICT "h38&h30&h31"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h38"]
lappend ans [list setpath _LMFILES_ "$mp/h38"]
lappend ans [list setpath MODULES_LMCONFLICT "h38&h30&h31"]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list unsetpath MODULES_LMNOTUASKED]
set tserr [list "unload h38" "unload h32" "unload h31" "unload h30" "load h38"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]

# unload of a useless requirement module and main module solves a conflict violation (just one reload)
setenv_loaded_module [list h30 h31 h32 h39] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h39"] [list h30 h31]
setenv_path_var MODULES_LMCONFLICT "h39&h31&h32"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h39"]
lappend ans [list setpath _LMFILES_ "$mp/h39"]
lappend ans [list setpath MODULES_LMCONFLICT "h39&h31&h32"]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list unsetpath MODULES_LMNOTUASKED]
set tserr [list "unload h39" "unload h32" "unload h31" "unload h30" "load h39"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]

# unload of a useless requirement module and main module reduce a conflict violation but one conflicting module is still loaded (no reload)
setenv_loaded_module [list h30 h31 h32 h40 h34] [list "$mp/h30" "$mp/h31" "$mp/h32" "$mp/h40" "$mp/h34"] [list h30 h31]
setenv_path_var MODULES_LMCONFLICT "h40&h31&h32&h34"
set ans [list]
lappend ans [list setpath LOADEDMODULES "h40:h34"]
lappend ans [list setpath _LMFILES_ "$mp/h40:$mp/h34"]
lappend ans [list unsetpath MODULES_LMPREREQ]
lappend ans [list unsetpath MODULES_LMNOTUASKED]
set tserr [list "unload h32" "unload h31" "unload h30"]
testouterr_cmd_re "sh" "unload h32" $ans [join $tserr "\n"]


#
#  Cleanup
#

# restore environment
setenv_path_var MODULEPATH $modpath
unsetenv_path_var MODULES_LMPREREQ
unsetenv_path_var MODULES_LMCONFLICT
unsetenv_path_var FOO
unsetenv_loaded_module

unsetenv_var MODULES_AUTO_HANDLING

unset mp
unset ans
