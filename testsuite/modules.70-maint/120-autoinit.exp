##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		modules.70-maint/%M%
#   Revision:		%I%
#   First Edition:	2017/05/20
#   Last Mod.:		%U%, %G%
#
#   Authors:		Xavier Delaruelle, xavier.delaruelle@cea.fr
#
#   Description:	Testuite testsequence
#   Command:		autoinit
#   Modulefiles:
#   Sub-Command:
#
#   Comment:	%C{
#			Tests the module command 'autoinit'
#		}C%
#
##############################################################################

#
#  Test variables
#

set path_list {}
foreach elt [file split [file join [pwd] $MODULECMD]] {
    if {$elt ne "."} {
        lappend path_list $elt
    }
}
set modulecmd_path [regsub -all "\(\[.+?\]\)" [eval file join $path_list] {\\\1}]
set moduleshome $install_prefix

# compare init config files to determine if we can guess expected setup
set insmodspath [file readable $install_initdir/.modulespath]
set modspath_exinstalled 0
if {[file readable $env(TESTSUITEDIR)/example/.modulespath]} {
    set fid [open $env(TESTSUITEDIR)/example/.modulespath r]
    set exmodspathdata [split [read $fid] "\n"]
    close $fid
    if {$insmodspath} {
        set fid [open $install_initdir/.modulespath r]
        set insmodspathdata [split [read $fid] "\n"]
        close $fid
    } else {
        set insmodspathdata ""
    }
    if {$exmodspathdata eq $insmodspathdata} {
        set modspath_exinstalled 1
    }
}

set insmodrc [file readable $install_initdir/modulerc]
set modrc_exinstalled 0
if {[file readable $env(TESTSUITEDIR)/example/modulerc]} {
    set fid [open $env(TESTSUITEDIR)/example/modulerc r]
    set exmodrcdata [split [read $fid] "\n"]
    close $fid
    if {$insmodrc} {
        set fid [open $install_initdir/modulerc r]
        set insmodrcdata [split [read $fid] "\n"]
        set insmodrc 1
        close $fid
    } else {
        set insmodrcdata ""
    }
    if {$exmodrcdata eq $insmodrcdata} {
        set modrc_exinstalled 1
    }
}

set err_lisp "$error_msgs: lisp mode autoinit not yet implemented"

set end_quar_sh "\\s*if \\\[ \"\\\${_mlv}\" = \"\\\${_mlv##\\\*\\\[\\\!A-Za-z0-9_\\\]}\" -a \"\\\${_mlv}\" = \"\\\${_mlv#\\\[0-9\\\]}\" \\\]; then
\\s*if \\\[ -n \"`eval 'echo \\\${'\\\$_mlv'\\\+x}'`\" \\\]; then
\\s*_mlre=\"\\\${_mlre}\\\${_mlv}_modquar='`eval 'echo \\\${'\\\$_mlv'}'`' \";
\\s*fi;
\\s*_mlrv=\"MODULES_RUNENV_\\\${_mlv}\";
\\s*_mlre=\"\\\${_mlre}\\\${_mlv}='`eval 'echo \\\${'\\\$_mlrv'}'`' \";
\\s*fi;
\\s*done;
\\s*if \\\[ -n \"\\\$_mlre\" \\\]; then
\\s*_mlre=\"eval \\\${_mlre}\";
\\s*fi;"
set func_quar_sh "\\s*local _mlre=''; local _mlv; local _mlrv;
\\s*for _mlv in \\\${MODULES_RUN_QUARANTINE}; do
$end_quar_sh"
set func_quar_zsh "\\s*typeset _mlre=''; typeset _mlv; typeset _mlrv;
\\s*for _mlv in \\\${=MODULES_RUN_QUARANTINE}; do
$end_quar_sh"
set func_quar_sh_other "\\s*typeset _mlre=''; typeset _mlv; typeset _mlrv;
\\s*for _mlv in \\\${MODULES_RUN_QUARANTINE}; do
$end_quar_sh"

set func_sh "module\\\(\\\) {\n$func_quar_sh\n\\s*eval `\\\${_mlre}$install_tclsh $modulecmd_path sh \\$\\*`;\n};"
set func_bash "module\\\(\\\) {\n$func_quar_sh_other\n\\s*eval `\\\${_mlre}$install_tclsh $modulecmd_path bash \\$\\*`;\n};"
set func_ksh "module\\\(\\\) {\n$func_quar_sh_other\n\\s*eval `\\\${_mlre}$install_tclsh $modulecmd_path ksh \\$\\*`;\n};"
set func_zsh "module\\\(\\\) {\n$func_quar_zsh\n\\s*eval `\\\${=_mlre}$install_tclsh $modulecmd_path zsh \\$\\*`;\n};"
set func_csh "if \\\( \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$install_tclsh $modulecmd_path csh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; set prompt=\"\\\$_prompt\"; unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; eval `$install_tclsh $modulecmd_path csh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$install_tclsh $modulecmd_path csh \\\\!\\*`; set _exit=\"\\\$status\";  set prompt=\"\\\$_prompt\";unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'eval `$install_tclsh $modulecmd_path csh \\\\!\\*`' ;"
set func_tcsh "if \\\( \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$install_tclsh $modulecmd_path tcsh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; set prompt=\"\\\$_prompt\"; unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; eval `$install_tclsh $modulecmd_path tcsh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$install_tclsh $modulecmd_path tcsh \\\\!\\*`; set _exit=\"\\\$status\";  set prompt=\"\\\$_prompt\";unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'eval `$install_tclsh $modulecmd_path tcsh \\\\!\\*`' ;"
set func_fish "function module
   eval \\S+tclsh $modulecmd_path fish \\$argv | source -
end"
set func_tcl "proc module {args} {
   catch {eval exec \"$install_tclsh\" \"$modulecmd_path\" \"tcl\" \\\$args 2>@stderr} script
   uplevel \\\$script;
}"
set func_perl "sub module {
   eval `$install_tclsh $modulecmd_path perl \\@_`;
   if\\\(\\$\\@\\\) {
      use Carp;
      confess \"module-error: \\$\\@\";
   }
   return 1;
}"
set func_python "import subprocess
def module\\\(command, \\*arguments\\\):
   exec\\\(subprocess\\.Popen\\\(\\\['$install_tclsh', '$modulecmd_path', 'python', command\\\] \\+ list\\\(arguments\\\), stdout=subprocess\\.PIPE\\\)\\.communicate\\\(\\\)\\\[0\\\]\\\)"
set func_ruby "class ENVModule
   def ENVModule.module\\\(\\*args\\\)
      if args\\\[0\\\].kind_of\\?\\\(Array\\\) then
         args = args\\\[0\\\].join\\\(' '\\\)
      else
         args = args.join\\\(' '\\\)
      end
      eval `$install_tclsh $modulecmd_path ruby #{args}`
   end
end"
set func_cmake "function\\\(module\\\)
   execute_process\\\(COMMAND mktemp -t moduleinit.cmake.XXXXXXXXXXXX
      OUTPUT_VARIABLE tempfile_name\\\)
   execute_process\\\(COMMAND $install_tclsh $modulecmd_path cmake \\\${ARGV}
      OUTPUT_FILE \\\${tempfile_name}\\\)
   if\\\(EXISTS \\\${tempfile_name}\\\)
      include\\\(\\\${tempfile_name}\\\)
      file\\\(REMOVE \\\${tempfile_name}\\\)
   endif\\\(\\\)
endfunction\\\(module\\\)"
set func_r "module <- function\\\(...\\\){
   arglist <- as.list\\\(match.call\\\(\\\)\\\)
   arglist\\\[1\\\] <- 'r'
   args <- paste0\\\(arglist, collapse=' '\\\)
   cmd <- paste\\\('$install_tclsh', '$modulecmd_path', args, sep=' '\\\)
   hndl <- pipe\\\(cmd\\\)
   eval\\\(expr = parse\\\(file=hndl\\\)\\\)
   close\\\(hndl\\\)
   invisible\\\(0\\\)
}"

#
#  test autoinit command for the different shells
#

# setup environment state
if { $verbose > 0 } {
    send_user "\tSetup LOADEDMODULES = foo\n"
}
set env(LOADEDMODULES) "foo"

foreach shell $supported_shells {
    if {$shell eq "lisp"} {
        testouterr_cmd "lisp" "autoinit" "ERR" "$err_lisp"
    } else {
        set ans [list]
        lappend ans [list [set "func_$shell"]]
        lappend ans [list set MODULESHOME $moduleshome]

        test_cmd_re $shell "autoinit" $ans
    }
}

# setup environment state
if { $verbose > 0 } {
    send_user "\tRestore LOADEDMODULES = ''\n"
    send_user "\tSetup MODULEPATH = ''\n"
}
unset env(LOADEDMODULES)
unset env(MODULEPATH)

if {(!$insmodspath || $modspath_exinstalled) && (!$insmodrc || $modrc_exinstalled)} {
    foreach shell $supported_shells {
        if {$shell eq "lisp"} {
            testouterr_cmd "lisp" "autoinit" "ERR" "$err_lisp"
        } else {
            set ans [list]
            lappend ans [list [set "func_$shell"]]
            if {!$insmodspath && !$insmodrc} {
                lappend ans [list set LOADEDMODULES ""]
                lappend ans [list set MODULESHOME $moduleshome]
                lappend ans [list set MODULEPATH ""]
            } elseif {$modspath_exinstalled} {
                lappend ans [list set MODULEPATH_modshare "(.*)"]
                lappend ans [list set LOADEDMODULES ""]
                lappend ans [list set MODULESHOME $moduleshome]
                lappend ans [list set MODULEPATH "$install_modulefilesdir:$install_prefix/test/modulefiles:$install_prefix/test/etc"]
            } elseif {!$insmodspath && $modrc_exinstalled} {
                lappend ans [list set _LMFILES__modshare "$install_modulefilesdir/null:1"]
                lappend ans [list set LOADEDMODULES_modshare "null:1"]
                lappend ans [list set MODULEPATH_modshare "$install_modulefilesdir:1"]
                lappend ans [list set _LMFILES_ "$install_modulefilesdir/null"]
                lappend ans [list set LOADEDMODULES "null"]
                lappend ans [list set MODULESHOME $moduleshome]
                lappend ans [list set MODULEPATH "$install_modulefilesdir"]
            }

            test_cmd_re $shell "autoinit" $ans
        }
    }
} else {
    send_user "\tskipping autoinit tests as installed configuration unknown\n"
}

# restore environment state
if { $verbose > 0 } {
    send_user "\tRestore MODULEPATH = $modpath\n"
}
set env(MODULEPATH) $modpath


#
#  Cleanup
#

unset path_list
unset modulecmd_path
unset moduleshome

if {[info exists fid]} {
    unset fid
}
if {[info exists exmodspathdata]} {
    unset exmodspathdata
}
if {[info exists exmodrcdata]} {
    unset exmodrcdata
}
if {[info exists insmodspathdata]} {
    unset insmodspathdata
}
unset insmodspath
if {[info exists insmodrcdata]} {
    unset insmodrcdata
}
unset insmodrc
unset modspath_exinstalled
unset modrc_exinstalled

unset shell
unset ans

unset err_lisp

unset end_quar_sh
unset func_quar_sh
unset func_quar_zsh
unset func_quar_sh_other

unset func_sh
unset func_bash
unset func_ksh
unset func_zsh
unset func_csh
unset func_tcsh
unset func_fish
unset func_tcl
unset func_perl
unset func_python
unset func_ruby
unset func_cmake
unset func_r
