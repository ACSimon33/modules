##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		modules.70-maint/%M%
#   Revision:		%I%
#   First Edition:	2017/05/20
#   Last Mod.:		%U%, %G%
#
#   Authors:		Xavier Delaruelle, xavier.delaruelle@cea.fr
#
#   Description:	Testuite testsequence
#   Command:		autoinit
#   Modulefiles:
#   Sub-Command:
#
#   Comment:	%C{
#			Tests the module command 'autoinit'
#		}C%
#
##############################################################################

#
#  Test variables
#

set path_list {}
foreach elt [file split [file join [pwd] $MODULECMD]] {
    if {$elt ne "."} {
        lappend path_list $elt
    }
}
set modulecmd_path [regsub -all "\(\[.+?\]\)" [eval file join $path_list] {\\\1}]
set moduleshome $install_prefix

if {[info exists env(TCLSH)]} {
    set tclsh_path $env(TCLSH)
} else {
    set tclsh_path "\\S+tclsh"
}

# compare init config files to determine if we can guess expected setup
set fid [open $env(TESTSUITEDIR)/example/.modulespath r]
set exmodspathdata [split [read $fid] "\n"]
close $fid
set fid [open $env(TESTSUITEDIR)/example/modulerc r]
set exmodrcdata [split [read $fid] "\n"]
close $fid
if {[file readable $install_initdir/.modulespath]} {
    set fid [open $install_initdir/.modulespath r]
    set insmodspathdata [split [read $fid] "\n"]
    close $fid
    set insmodspath 1
} else {
    set insmodspathdata ""
    set insmodspath 0
}
if {[file readable $install_initdir/modulerc]} {
    set fid [open $install_initdir/modulerc r]
    set insmodrcdata [split [read $fid] "\n"]
    set insmodrc 1
    close $fid
} else {
    set insmodrcdata ""
    set insmodrc 0
}
if {$exmodspathdata eq $insmodspathdata} {
    set modspath_exinstalled 1
} else {
    set modspath_exinstalled 0
}
if {$exmodrcdata eq $insmodrcdata} {
    set modrc_exinstalled 1
} else {
    set modrc_exinstalled 0
}

set err_lisp "$error_msgs: lisp mode autoinit not yet implemented"

set func_sh "module\\\(\\\) { eval `$tclsh_path $modulecmd_path sh \\$\\*`; };"
set func_bash "module\\\(\\\) { eval `$tclsh_path $modulecmd_path bash \\$\\*`; };"
set func_ksh "module\\\(\\\) { eval `$tclsh_path $modulecmd_path ksh \\$\\*`; };"
set func_zsh "module\\\(\\\) { eval `$tclsh_path $modulecmd_path zsh \\$\\*`; };"
set func_csh "if \\\( \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$tclsh_path $modulecmd_path csh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; set prompt=\"\\\$_prompt\"; unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; eval `$tclsh_path $modulecmd_path csh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$tclsh_path $modulecmd_path csh \\\\!\\*`; set _exit=\"\\\$status\";  set prompt=\"\\\$_prompt\";unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'eval `$tclsh_path $modulecmd_path csh \\\\!\\*`' ;"
set func_tcsh "if \\\( \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$tclsh_path $modulecmd_path tcsh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; set prompt=\"\\\$_prompt\"; unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'set _histchars = \\\$histchars; unset histchars; eval `$tclsh_path $modulecmd_path tcsh \\\\!\\*`; set _exit=\"\\\$status\";  set histchars = \\\$_histchars; unset _histchars; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\$\\\?prompt \\\)  alias module 'set _prompt=\"\\\$prompt\"; set prompt=\"\"; eval `$tclsh_path $modulecmd_path tcsh \\\\!\\*`; set _exit=\"\\\$status\";  set prompt=\"\\\$_prompt\";unset _prompt; test 0 = \\\$_exit' ;
if \\\( \\\! \\\$\\\?histchars && \\\! \\\$\\\?prompt \\\)  alias module 'eval `$tclsh_path $modulecmd_path tcsh \\\\!\\*`' ;"
set func_fish "function module
   eval \\S+tclsh $modulecmd_path fish \\$argv | source -
end"
set func_tcl "proc module {args} {
   global env;
   set script {};
   catch {set script \\\[eval exec \"$tclsh_path\" \"$modulecmd_path\" \"tcl\" \\\$args 2>@stderr\\\]}
   uplevel \\\$script;
}"
set func_perl "sub module {
   eval `$tclsh_path $modulecmd_path perl \\@_`;
   if\\\(\\$\\@\\\) {
      use Carp;
      confess \"module-error: \\$\\@
\";
   }
   return 1;
}"
set func_python "import subprocess
def module\\\(command, \\*arguments\\\):
   exec\\\(subprocess\\.Popen\\\(\\\['$tclsh_path', '$modulecmd_path', 'python', command\\\] \\+ list\\\(arguments\\\), stdout=subprocess\\.PIPE\\\)\\.communicate\\\(\\\)\\\[0\\\]\\\)"
set func_ruby "class ENVModule
   def ENVModule.module\\\(\\*args\\\)
      if args\\\[0\\\].kind_of\\?\\\(Array\\\) then
         args = args\\\[0\\\].join\\\(' '\\\)
      else
         args = args.join\\\(' '\\\)
      end
      eval `$tclsh_path $modulecmd_path ruby #{args}`
   end
end"
set func_cmake "function\\\(module\\\)
   execute_process\\\(COMMAND mktemp -t moduleinit.cmake.XXXXXXXXXXXX
      OUTPUT_VARIABLE tempfile_name\\\)
   execute_process\\\(COMMAND $tclsh_path $modulecmd_path cmake \\\${ARGV}
      OUTPUT_FILE \\\${tempfile_name}\\\)
   if\\\(EXISTS \\\${tempfile_name}\\\)
      include\\\(\\\${tempfile_name}\\\)
      file\\\(REMOVE \\\${tempfile_name}\\\)
   endif\\\(\\\)
endfunction\\\(module\\\)"
set func_r "module <- function\\\(...\\\){
   arglist <- as.list\\\(match.call\\\(\\\)\\\)
   arglist\\\[1\\\] <- 'r'
   args <- paste0\\\(arglist, collapse=' '\\\)
   cmd <- paste\\\('$tclsh_path', '$modulecmd_path', args, sep=' '\\\)
   hndl <- pipe\\\(cmd\\\)
   eval\\\(expr = parse\\\(file=hndl\\\)\\\)
   close\\\(hndl\\\)
   invisible\\\(0\\\)
}"

#
#  test autoinit command for the different shells
#

# setup environment state
if { $verbose > 0 } {
    send_user "\tSetup LOADEDMODULES = foo\n"
}
set env(LOADEDMODULES) "foo"

foreach shell $supported_shells {
    if {$shell eq "lisp"} {
        testouterr_cmd "lisp" "autoinit" "ERR" "$err_lisp"
    } else {
        set ans [list]
        lappend ans [list [set "func_$shell"]]
        lappend ans [list set MODULESHOME $moduleshome]

        test_cmd_re $shell "autoinit" $ans
    }
}

# setup environment state
if { $verbose > 0 } {
    send_user "\tRestore LOADEDMODULES = ''\n"
    send_user "\tSetup MODULEPATH = ''\n"
}
unset env(LOADEDMODULES)
unset env(MODULEPATH)

if {(!$insmodspath || $modspath_exinstalled) && (!$insmodrc || $modrc_exinstalled)} {
    foreach shell $supported_shells {
        if {$shell eq "lisp"} {
            testouterr_cmd "lisp" "autoinit" "ERR" "$err_lisp"
        } else {
            set ans [list]
            lappend ans [list [set "func_$shell"]]
            if {!$insmodspath && !$insmodrc} {
                lappend ans [list set LOADEDMODULES ""]
                lappend ans [list set MODULESHOME $moduleshome]
                lappend ans [list set MODULEPATH ""]
            } elseif {$modspath_exinstalled} {
                lappend ans [list set MODULEPATH_modshare "(.*)"]
                lappend ans [list set LOADEDMODULES ""]
                lappend ans [list set MODULESHOME $moduleshome]
                lappend ans [list set MODULEPATH "/usr/share/Modules/modulefiles:/etc/modulefiles:/usr/share/modulefiles"]
            } elseif {!$insmodspath && $modrc_exinstalled} {
                lappend ans [list set _LMFILES__modshare "/usr/share/Modules/modulefiles/null:1"]
                lappend ans [list set LOADEDMODULES_modshare "null:1"]
                lappend ans [list set MODULEPATH_modshare "/usr/share/Modules/modulefiles:1"]
                lappend ans [list set _LMFILES_ "/usr/share/Modules/modulefiles/null"]
                lappend ans [list set LOADEDMODULES "null"]
                lappend ans [list set MODULESHOME $moduleshome]
                lappend ans [list set MODULEPATH "/usr/share/Modules/modulefiles"]
            }

            test_cmd_re $shell "autoinit" $ans
        }
    }
} else {
    send_user "\tskipping autoinit tests as installed configuration unknown\n"
}

# restore environment state
if { $verbose > 0 } {
    send_user "\tRestore MODULEPATH = $modpath\n"
}
set env(MODULEPATH) $modpath


#
#  Cleanup
#

unset path_list
unset modulecmd_path
unset moduleshome

unset fid
unset exmodspathdata
unset exmodrcdata
unset insmodspathdata
unset insmodspath
unset insmodrcdata
unset insmodrc
unset modspath_exinstalled
unset modrc_exinstalled

unset shell
unset ans

unset err_lisp

unset func_sh
unset func_bash
unset func_ksh
unset func_zsh
unset func_csh
unset func_tcsh
unset func_fish
unset func_tcl
unset func_perl
unset func_python
unset func_ruby
unset func_cmake
unset func_r
