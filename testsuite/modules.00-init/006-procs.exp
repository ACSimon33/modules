##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		modules.00-init/%M%
#   Revision:		%I%
#   First Edition:	95/12/06
#   Last Mod.:		%U%, %G%
#
#   Authors:		Jens Hamisch, Jens.Hamisch@Strawberry.COM
#
#   Description:	Test procedures
#   Command:
#   Sub-Command:
#
#   Comment:	%C{
#			Defines the testprocedures for probing the outputs
#			on stdout and stderr of the test target
#		}C%
#
##############################################################################

#
# Test subprocedure
#

proc _test_sub {test_shell cmd answer} {
    global comp_output
    global comp_error
    global shell
    global verbose

    if { $verbose > 0 } {
	send_user "   ...  Testing 'modulecmd $test_shell $cmd'\n"
    }
    set comp_output ""
    set comp_error ""

    if { ![info exists test_shell] || ![info exists answer] ||
	 ![info exists cmd] } {
	unresolved "$cmd ($test_shell) internal error"
    }

    set shell $test_shell
    modulecmd_start "$cmd"

    if { $verbose > 1 } {
	send_user "OUT: $comp_output\n"
	send_user "ERR: $comp_error\n"
    }
}

#
# Test procedure for matching with regular expressions
#

proc test_cmd_re {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose
    
    _test_sub $test_shell "$cmd" "$answer"

    if { ![regexp $answer $comp_output] } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "OUT: $comp_output\n"
	    send_user "EXP (re): $answer\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

#
#  Test procedure for full text matching
#

proc test_cmd {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose

    _test_sub $test_shell "$cmd" "$answer"

    if { $comp_output != "$answer" } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "OUT: $comp_output\n"
	    send_user "EXP: $answer\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

#
# Test procedure for matching with regular expressions in the error output
#

proc testerr_cmd_re {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose
    
    _test_sub $test_shell "$cmd" "$answer"

    if { ![regexp $answer $comp_error] } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "ERR: $comp_error\n"
	    send_user "EXP (re): $answer\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

#
#  Test procedure for full text matching in the error output
#

proc testerr_cmd {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose

    _test_sub $test_shell "$cmd" "$answer"

    if { $comp_error != "$answer" } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "ERR: $comp_error\n"
	    send_user "EXP: $answer\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

