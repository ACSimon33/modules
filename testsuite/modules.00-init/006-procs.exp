##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		modules.00-init/%M%
#   Revision:		%I%
#   First Edition:	95/12/06
#   Last Mod.:		%U%, %G%
#
#   Authors:		Jens Hamisch, Jens.Hamisch@Strawberry.COM
#
#   Description:	Test procedures
#   Command:
#   Sub-Command:
#
#   Comment:	%C{
#			Defines the testprocedures for probing the outputs
#			on stdout and stderr of the test target
#		}C%
#
##############################################################################

#
# some tests only apply if the configure option is enabled or not
#   look at ./modulecmd --version for examples
#   (e.g. version_test("XXX=undef") returns 0 or 1 if the string is found)
# 	if { [ version_test "XXX=1" ] } {
#	} else {
#	}
#
proc version_test {which} {
	global comp_output
	global comp_error
	global verbose

	if { $verbose > 1 } {
		send_user "   ...  version_test($which)\n"
	}
	set comp_output ""
	set comp_error ""

	if { ![info exists which] } {
		unresolved "version_test ($which) internal error"
	}

	modulecmd__ "--version"

	if { ![regexp -- ".*$which.*" $comp_error] } {
		if { $verbose > 1 } {
			send_user "version_test: 0\n"
		}
		return 0
	} else {
		if { $verbose > 1 } {
			send_user "version_test: 1\n"
		}
		return 1
	}
}

#
# Shell conversion code subprocedures
#

proc shell_err {test_shell {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
           set answer "/bin/false;"
        }
        {tcl} {
            set answer "exec /bin/false;"
        }
        {perl} {
            set answer "die \"modulefile.tcl: 1 error${esc}(s${esc}) detected!${esc}\\n\""
        }
        {python} {
            set answer "raise RuntimeError${esc}( 'modulefile.tcl: 1 error${esc}(s${esc}) detected!'${esc})"
        }
        {lisp} {
            set answer "${esc}(error \"modulefile.tcl: 1 error${esc}(s${esc}) detected!\"${esc})"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_ok {test_shell {re_mode 0}} {
    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
            set answer "/bin/true;"
        }
        {tcl} {
            set answer "exec /bin/true;"
        }
        {perl} {
            set answer "1;"
        }
        {lisp} {
            set answer "t"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_val {test_shell val {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
            set val [regsub -all {([\\])} $val {\\\1}]
            set val [regsub -all {([ ])} $val {\\\\\1}]
        }
        {tcl} - {lisp} {
            set val [regsub -all {(["])} $val {\\\1}]
        }
        {perl} - {python} {
            set val [regsub -all {(['])} $val {\\\1}]
        }
    }
    return $val
}

proc shell_set {test_shell var val {re_mode 0} {escval 1}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    if {$escval} {
        set val [shell_val $test_shell $val $re_mode]
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} {
            set answer "$var=$val; export $var;"
        }
        {csh} - {tcsh} {
            set answer "setenv $var $val;"
        }
        {fish} {
            if {$var eq "PATH"} {
                regsub -all ":" $val " " val
            }
            set answer "set -xg $var $val;"
        }
        {tcl} {
            set answer "set env${esc}($var${esc}) \"$val\";"
        }
        {perl} {
            set answer "${esc}\$ENV{'$var'} = '$val';"
        }
        {python} {
            set answer "os.environ${esc}\['$var'${esc}\] = '$val'"
        }
        {lisp} {
            set answer "${esc}(setenv \"$var\" \"$val\"${esc})"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_unset {test_shell var {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} {
            set answer "unset $var;"
        }
        {csh} - {tcsh} {
            set answer "unsetenv $var;"
        }
        {fish} {
            set answer "set -e $var;"
        }
        {tcl} {
            set answer "unset env${esc}($var${esc});"
        }
        {perl} {
            set answer "delete ${esc}\$ENV{'$var'};"
        }
        {python} {
            set answer "os.environ${esc}\['$var'${esc}\] = ''\n"
            append answer "del os.environ${esc}\['$var'${esc}\]"
        }
        {lisp} {
            set answer "${esc}(setenv \"$var\" nil${esc})"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_alias {test_shell var val {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} {
            set answer "alias $var='$val';"
        }
        {csh} - {tcsh} - {fish} {
            set answer "alias $var '$val';"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_unalias {test_shell var {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} {
            set answer "unalias $var;"
        }
        {fish} {
            set answer "functions -e $var;"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_chdir {test_shell val {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
            set answer "cd '$val';"
        }
        {tcl} {
            set answer "cd \"$val\";"
        }
        {perl} {
            set answer "chdir '$val';"
        }
        {python} {
            set answer "os.chdir${esc}('$val'${esc})"
        }
        {lisp} {
            set answer "${esc}(shell-command-to-string \"cd '$val'\"${esc})"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_xres {test_shell var val first {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }
    set xrdb "(${esc}\S*)xrdb"

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
            if {$val ne ""} {
                set answer "echo \"$var: $val\" ${esc}| $xrdb -merge;"
            } else {
                set answer "$xrdb -merge $var;"
            }
        }
        {tcl} {
            if {$val ne ""} {
                set answer "set XRDBPIPE ${esc}\[open \"${esc}|$xrdb -merge\" r${esc}+${esc}\];\n"
                append answer "puts ${esc}\$XRDBPIPE \"$var: $val\";\n"
                append answer "close ${esc}\$XRDBPIPE;\n"
                append answer "unset XRDBPIPE;"
            } else {
                set answer "exec $xrdb -merge $var;"
            }
        }
        {perl} {
            if {$val ne ""} {
                set answer "open${esc}(XRDBPIPE, \"${esc}|$xrdb -merge\"${esc});\n"
                append answer "print XRDBPIPE \"$var: $val${esc}\\n\";\n"
                append answer "close XRDBPIPE;"
            } else {
                set answer "system${esc}(\"$xrdb -merge $var\"${esc});"
            }
        }
        {python} {
            if {$first} {
                set answer "import subprocess\n"
            }
            if {$val ne ""} {
                append answer "subprocess.Popen${esc}(${esc}\['$xrdb', '-merge'${esc}\], stdin=subprocess.PIPE${esc}).communicate${esc}(input=\'$var: $val${esc}\\n\'${esc})"
            } else {
                append answer "subprocess.Popen${esc}(${esc}\['$xrdb', '-merge', '$var'${esc}\]${esc})"
            }
        }
        {lisp} {
            if {$val ne ""} {
                set answer "${esc}(shell-command-to-string \"echo $var: $val ${esc}| $xrdb -merge\"${esc})"
            } else {
                set answer "${esc}(shell-command-to-string \"$xrdb -merge $var\"${esc})"
            }
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_unxres {test_shell var first {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }
    set xrdb "(${esc}\S*)xrdb"

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
            set answer "echo \"$var:\" ${esc}| $xrdb -merge;"
        }
        {tcl} {
            set answer "set XRDBPIPE ${esc}\[open \"${esc}|$xrdb -merge\" r${esc}+${esc}\];\n"
            append answer "puts ${esc}\$XRDBPIPE \"$var:\";\n"
            append answer "close ${esc}\$XRDBPIPE;\n"
            append answer "unset XRDBPIPE;"
        }
        {perl} {
            set answer "open${esc}(XRDBPIPE, \"${esc}|$xrdb -merge\"${esc});\n"
            append answer "print XRDBPIPE \"$var:${esc}\\n\";\n"
            append answer "close XRDBPIPE;"
        }
        {python} {
            if {$first} {
                set answer "import subprocess\n"
            }
            append answer "subprocess.Popen${esc}(${esc}\['$xrdb', '-merge'${esc}\], stdin=subprocess.PIPE${esc}).communicate${esc}(input=\'$var:${esc}\\n\'${esc})"
        }
        {lisp} {
            set answer "${esc}(shell-command-to-string \"echo $var: ${esc}| $xrdb -merge\"${esc})"
        }
        default {
            set answer ""
        }
    }

    return $answer
}

proc shell_echo {test_shell val {re_mode 0}} {
    if {$re_mode} {
        set esc "\\"
    } else {
        set esc ""
    }

    switch -- $test_shell {
        {sh} - {bash} - {ksh} - {zsh} - {csh} - {tcsh} - {fish} {
            set answer "echo '$val';"
        }
        {tcl} {
            set answer "puts \"$val\";"
        }
        {perl} {
            set answer "print '$val'.\"\\n\";"
        }
        {python} {
            set answer "print '$val'"
        }
        {lisp} {
            set answer "${esc}(message \"$val\"${esc})"
        }
        default {
            set answer ""
        }
    }

    return $answer
}


# provide a lassign proc for Tcl8.4 and earlier
if {[info commands lassign] eq ""} {
   proc lassign {values args} {
      uplevel 1 [list foreach $args [linsert $values end {}] break]
      lrange $values [llength $args] end
   }
}

proc shell_out {test_shell out_list {re_mode 0}} {
    set answer_list {}
    set fixed_list {}
    array set envvar {}
    array set autovar {}
    set status_set 0
    set first_xres 1

    foreach out $out_list {
        lassign $out cmd var val extra
        switch -- $cmd {
            {set} {
                if {$extra eq "noescval"} {
                    set escval 0
                } else {
                    set escval 1
                }
                set envvar($var) [shell_set $test_shell $var $val $re_mode $escval]
                lappend answer_list $envvar($var)

                # automatic specification of ref counter var is removed if set
                if {[info exists autovar($var)]} {
                    unset autovar($var)
                }
            }
            {setpath} {
                set envvar($var) [shell_set $test_shell $var $val $re_mode]
                lappend answer_list $envvar($var)

                # automatically set ref counter variable if not specified
                set sharevar "${var}_modshare"
                if {![info exists envvar($sharevar)]} {
                    set envvar($sharevar) [shell_set $test_shell $sharevar "(.*)" $re_mode]
                    set autovar($sharevar) 1
                }
            }
            {unset} {
                set envvar($var) [shell_unset $test_shell $var $re_mode]
                lappend answer_list $envvar($var)

                # automatic specification of ref counter var is removed if set
                if {[info exists autovar($var)]} {
                    unset autovar($var)
                }
            }
            {unsetpath} {
                set envvar($var) [shell_unset $test_shell $var $re_mode]
                lappend answer_list $envvar($var)

                # automatically set ref counter variable if not specified
                set sharevar "${var}_modshare"
                if {![info exists envvar($sharevar)]} {
                    set envvar($sharevar) [shell_unset $test_shell $sharevar $re_mode]
                    set autovar($sharevar) 1
                }
            }
            {alias} {
                set ret [shell_alias $test_shell $var $val $re_mode]
                if {$ret ne ""} {
                    lappend fixed_list $ret
                    lappend answer_list $ret
                }
            }
            {unalias} {
                set ret [shell_unalias $test_shell $var $re_mode]
                 if {$ret ne ""} {
                    lappend fixed_list $ret
                    lappend answer_list $ret
                }
            }
            {chdir} {
                set ret [shell_chdir $test_shell $var $re_mode]
                if {$ret ne ""} {
                    lappend fixed_list $ret
                    lappend answer_list $ret
                }
            }
            {xres} {
                set ret [shell_xres $test_shell $var $val $first_xres $re_mode]
                if {$ret ne ""} {
                    lappend fixed_list $ret
                    lappend answer_list $ret
                }
                set first_xres 0
            }
            {unxres} {
                set ret [shell_unxres $test_shell $var $first_xres $re_mode]
                 if {$ret ne ""} {
                    lappend fixed_list $ret
                    lappend answer_list $ret
                }
                set first_xres 0
            }
            {echo} {
                lappend fixed_list [shell_echo $test_shell $var $re_mode]
                lappend answer_list [lindex $fixed_list end]
            }
            {OK} {
                lappend fixed_list [shell_ok $test_shell $re_mode]
                lappend answer_list [lindex $fixed_list end]
                set status_set 1
            }
            {ERR} {
                lappend fixed_list [shell_err $test_shell $re_mode]
                lappend answer_list [lindex $fixed_list end]
                set status_set 1
            }
            default {
                lappend fixed_list [join $out]
                lappend answer_list [lindex $fixed_list end]
            }
        }
    }

    # specific order if var have been automatically set
    if {[array size autovar] > 0} {
        set answer_list {}
        foreach var [array names envvar] {
            lappend answer_list $envvar($var)
        }
        set answer_list [concat $answer_list $fixed_list]
    }


    if {$test_shell eq "python"} {
        set answer_list [concat [list "import os"] $answer_list]
    }

    if {!$status_set && $test_shell eq "perl"} {
        lappend answer_list "1;"
    }

    set answer [join $answer_list "\n"]

    return $answer
}

proc is_shell_out_list {answer} {
    set ret 0

    if {[string is list $answer]} {
        foreach item $answer {
            if {[llength $item] > 1} {
                switch -- [lindex $item 0] {
                    {set} - {setpath} - {unset} - {unsetpath} - {alias} \
                        - {unalias} - {echo} {
                        set ret 1
                        break
                    }
                }
            }
        }
    }

    return $ret
}

#
# Test subprocedures
#

proc _test_sub {test_shell cmd} {
	global comp_output
	global comp_error
	global comp_exit
	global shell
	global verbose

	if { $verbose > 0 } {
		send_user "   ...  Testing 'modulecmd $test_shell $cmd'\n"
	}
	set comp_output ""
	set comp_error ""
	set comp_exit ""

	if { ![info exists test_shell] || ![info exists cmd] } {
		unresolved "$cmd ($test_shell) internal error"
	}

	set shell $test_shell
	modulecmd_start "$cmd"

	if { $verbose > 1 } {
		set ol [string length $comp_output]
		set oe [string length $comp_error]
		send_user "OUT\[$ol\]: '$comp_output'\n"
		send_user "ERR\[$oe\]: '$comp_error'\n"
		send_user "EXIT: '$comp_exit'\n"
	}
}

proc _test_err {test_shell cmd answer} {
	global comp_error
	global verbose

	if { $comp_error != "$answer" } {
		fail "$cmd ($test_shell)"
		if { $verbose > 0 } {
			set ol [string length $comp_error]
			set oe [string length $answer]
			send_user "ERR\[$ol\]: '$comp_error'\n"
			send_user "EXP\[$oe\]: '$answer'\n"
		}
		return 0;
	} else {
		return 1;
	}
}

proc _test_err_re {test_shell cmd answer} {
	global comp_error
	global verbose

    set answer "^$answer\$"
	if { ![regexp -- $answer $comp_error] } {
		fail "$cmd ($test_shell)"
		if { $verbose > 0 } {
			set ol [string length $comp_error]
			set oe [string length $answer]
			send_user "ERR\[$ol\]: '$comp_error'\n"
			send_user "EXP\[$oe\]: '$answer'\n"
		}
		return 0;
	} else {
		return 1;
	}
}

proc _test_out {test_shell cmd answer} {
	global comp_output
	global verbose

    if {[is_shell_out_list $answer]} {
        set answer [shell_out $test_shell $answer]
    } elseif {$answer eq "ERR"} {
        set answer [shell_err $test_shell]
    } elseif {$answer eq "OK"} {
        set answer [shell_ok $test_shell]
    }

	if { $comp_output != "$answer" } {
		fail "$cmd ($test_shell)"
		if { $verbose > 0 } {
			set ol [string length $comp_output]
			set oe [string length $answer]
			send_user "OUT\[$ol\]: '$comp_output'\n"
			send_user "EXP\[$oe\]: '$answer'\n"
		}
		return 0;
	} else {
		return 1;
	}
}

proc _test_out_re {test_shell cmd answer} {
	global comp_output
	global verbose

    if {[is_shell_out_list $answer]} {
        set answer [shell_out $test_shell $answer 1]
    } elseif {$answer eq "ERR"} {
        set answer [shell_err $test_shell 1]
    } elseif {$answer eq "OK"} {
        set answer [shell_ok $test_shell 1]
    }

    set answer "^$answer\$"
	if { ![regexp -- $answer $comp_output] } {
		fail "$cmd ($test_shell)"
		if { $verbose > 0 } {
			set ol [string length $comp_output]
			set oe [string length $answer]
			send_user "OUT\[$ol\]: '$comp_output'\n"
			send_user "EXP\[$oe\]: '$answer'\n"
		}
		return 0;
	} else {
		return 1;
	}
}

proc _test_file {test_shell cmd filepath answer} {
	global verbose

    catch {
        set fd [open $filepath]
        read -nonewline $fd
    } comp_file
    catch { close $fd }

	if { $comp_file != "$answer" } {
		fail "$cmd ($test_shell)"
		if { $verbose > 0 } {
			set ol [string length $comp_file]
			set oe [string length $answer]
			send_user "FILE\[$ol\]: '$comp_file'\n"
			send_user "EXP\[$oe\]: '$answer'\n"
		}
		return 0;
	} else {
		return 1;
	}
}

proc _test_exit {test_shell cmd exitval} {
	global comp_exit
	global verbose

	if { $comp_exit != "$exitval" } {
		fail "$cmd ($test_shell)"
		if { $verbose > 0 } {
			send_user "EXIT: '$comp_exit'\n"
			send_user "EXP: '$exitval'\n"
		}
		return 0;
	} else {
		return 1;
	}
}

proc _test_ok {test_shell cmd} {
	pass "$cmd ($test_shell)"
}

#
# Test procedure for matching with regular expressions
#

proc test_cmd_re {test_shell cmd answer} {
    if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            test_cmd_re $shell $cmd $answer
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_out_re $test_shell "$cmd" "$answer" ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
#  Test procedure for full text matching
#

proc test_cmd {test_shell cmd answer {exitval 0}} {
    if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            test_cmd $shell $cmd $answer $exitval
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_out $test_shell "$cmd" "$answer" ]
        &&   [ _test_exit $test_shell "$cmd" "$exitval" ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
# Test procedure for matching with regular expressions in the error output
#

proc testerr_cmd_re {test_shell cmd answer} {
     if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            testerr_cmd_re $shell $cmd $answer
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_err_re $test_shell $cmd $answer ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
# Test procedure for matching with regular expressions in the stderr/stdout
#

proc testouterr_cmd_re {test_shell cmd answer anserr} {
    if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            testouterr_cmd_re $shell $cmd $answer $anserr
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_out_re $test_shell "$cmd" "$answer" ]
        &&   [ _test_err_re $test_shell "$cmd" "$anserr" ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
#  Test procedure for full text matching in the error output
#

proc testerr_cmd {test_shell cmd answer} {
    if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            testerr_cmd $shell $cmd $answer
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_err $test_shell "$cmd" "$answer" ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
# Test procedure for full text matching with the stderr/stdout
#

proc testouterr_cmd {test_shell cmd answer anserr} {
    if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            testouterr_cmd $shell $cmd $answer $anserr
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_out $test_shell "$cmd" "$answer" ]
        &&   [ _test_err $test_shell "$cmd" "$anserr" ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
# Test procedure for full text matching with stdout and specified file
#

proc testoutfile_cmd {test_shell cmd answer filepath ansfile} {
    if {$test_shell eq "ALL"} {
        global supported_shells
        foreach shell $supported_shells {
            testoutfile_cmd $shell $cmd $answer $filepath $ansfile
        }
    } else {
        _test_sub $test_shell "$cmd"
        if { [ _test_out $test_shell "$cmd" "$answer" ]
        &&   [ _test_file $test_shell "$cmd" "$filepath" "$ansfile" ] } {
            _test_ok $test_shell "$cmd"
        }
    }
}

#
# Change and restore file permissions to trigger specific behaviors
#

proc change_file_perms {name perms} {
    global verbose file_orig_perms

    # backup original file permission to restore them later
    set file_orig_perms($name) [file attributes $name -permissions]

    if { $verbose > 0 } {
        send_user "\tChange permissions of file $name ($perms)\n"
    }

    # lock file by removing read and execution perms
    file attributes $name -permissions $perms
}

proc restore_file_perms {name} {
    global verbose file_orig_perms

    if { $verbose > 0 } {
        send_user "\tRestore permissions of file $name ($file_orig_perms($name))\n"
    }

    # restore file original permissions
    file attributes $name -permissions $file_orig_perms($name)
}
