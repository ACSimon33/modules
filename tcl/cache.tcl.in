##########################################################################

# CACHE.TCL, cache management procedures
# Copyright (C) 2022 Xavier Delaruelle
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

##########################################################################

# Get full path name of module cache file for given modulepath
proc getModuleCacheFilename {modpath} {
   return $modpath/.modulecache
}

# Build cache file content for given modulepath
proc formatModuleCacheContent {modpath} {
   set content {}
   # collect files from modulepath directory
   array set found_list [findModules $modpath * 0 1]

   # build cache entry for every file found
   foreach elt [lsort [array names found_list]] {
      set entry_list [list]
      set fetch_content 0
      switch -- [lindex $found_list($elt) 0] {
         modulerc {
            lappend entry_list modulerc-content $elt
            set fetch_content 1
         }
         modulefile {
            lappend entry_list modulefile-content $elt [lindex\
               $found_list($elt) 1]
            set fetch_content 1
         }
         default {
            # also record obtained error to get all the information to cover
            # everything fetched by findModules. only modulefile validity is
            # checked in findModules
            lappend entry_list modulefile-invalid $elt {*}[lrange\
               $found_list($elt) 0 1]
         }
      }
      # fetch file content
      if {$fetch_content} {
         if {[catch {
            set fcontent [readFile $modpath/$elt]
            # extract module header from the start of the file
            if {![regexp {^#%Module[0-9\.]*} [string range $fcontent 0 32]\
               fheader]} {
               set fheader {}
            }
            lappend entry_list $fheader $fcontent
         } errMsg]} {
            # rethrow read error after parsing message
            knerror [parseAccessIssue $modpath/$elt]
         }
      }
      # format cache entry
      append content "\n$entry_list"
   }

   # prepend header if some content has been generated
   if {[string length $content] != 0} {
      regexp {^\d+\.\d+} {@MODULES_RELEASE@} majmin
      set content "#%Module$majmin$content"
   }

   return $content
}

# evaluate cache file
proc execute-cachefile {cachefile modpath} {
   # register current modulepath for cachefile commands to know where they are
   lappendState modulepath $modpath
   lappendState debug_msg_prefix "\[cache:$cachefile\] "

   #FIXME: create cache file evaluation interp

   #FIXME: evaluate cache file

   set exec_res 0
   reportDebug "exiting $cachefile (result=$exec_res)"

   lpopState debug_msg_prefix
   lpopState modulepath

   return $exec_res
}

# finds all module-related files matching mod in the modulepath dir by looking
# into the cache file
proc findModulesInCacheFile {modpath mod depthlvl fetch_mtime} {
   set cachefile [getModuleCacheFilename $modpath]

   # check if cache should be ignored
   if {[currentState commandname] eq {cachebuild}} {
      return {}
   }

   # check if a cache file is available
   if {![info exists ::g_cachefilesAvail($cachefile)]} {
      if {[set ::g_cachefilesAvail($cachefile) [file readable $cachefile]]} {
         reportDebug "cache file '$cachefile' exists and is readable"
      } else {
         reportDebug "cache file '$cachefile' cannot be found or read"
      }
   }

   # return if no cache file available
   if {!$::g_cachefilesAvail($cachefile)} {
      return {}
   }

   # evaluate cache file if not yet done
   if {![info exists ::g_cachefilesSourced($cachefile)]} {
      set exec_res [execute-cachefile $cachefile $modpath]
      # keep track of already sourced cache files not to run them again
      set ::g_cachefilesSourced($cachefile) $exec_res
   } else {
      reportDebug "cache file '$cachefile' has already been evaluated"
   }

   # return if cache file has not been correctly sourced
   if {!$::g_cachefilesSourced($cachefile)} {
      return {}
   }

   # tailor cache file content to what is requested
   set cache_list {}

   #FIXME

   return $cache_list
}

# ;;; Local Variables: ***
# ;;; mode:tcl ***
# ;;; End: ***
# vim:set tabstop=3 shiftwidth=3 expandtab autoindent:
